// CODE GENERATED. DO NOT EDIT.
package {{.PackageName}}

import (
	"encoding/json"
	"testing"
)

// TestGetData_SerializationDeserialization tests that data can be successfully
// serialized to JSON and deserialized back without data loss or corruption.
// This is a generic test that verifies the serialization/deserialization
// round-trip works correctly for any package using this data loader pattern.
func TestGetData_SerializationDeserialization(t *testing.T) {
	// Get original data from embedded filesystem
	originalData := GetData()
	
	if len(originalData) == 0 {
		t.Fatal("GetData() returned empty map, expected {{.DataContext}} data")
	}
	
	// Serialize to JSON
	root := struct {
		{{.RootFieldName}} map[string]*{{.StructName}} `json:"{{.RootJSONKey}}"`
	}{
		{{.RootFieldName}}: originalData,
	}
	
	jsonBytes, err := json.Marshal(root)
	if err != nil {
		t.Fatalf("Failed to marshal data: %v", err)
	}
	
	// Deserialize back from JSON
	var deserializedRoot struct {
		{{.RootFieldName}} map[string]*{{.StructName}} `json:"{{.RootJSONKey}}"`
	}
	
	if err := json.Unmarshal(jsonBytes, &deserializedRoot); err != nil {
		t.Fatalf("Failed to unmarshal data: %v", err)
	}
	
	// Verify data integrity: count should match
	if len(deserializedRoot.{{.RootFieldName}}) != len(originalData) {
		t.Errorf("Deserialized data count = %d, want %d", 
			len(deserializedRoot.{{.RootFieldName}}), len(originalData))
	}
	
	// Verify that all keys from original exist in deserialized and vice versa
	for key := range originalData {
		if _, exists := deserializedRoot.{{.RootFieldName}}[key]; !exists {
			t.Errorf("Key %q exists in original but not in deserialized data", key)
		}
	}
	
	for key := range deserializedRoot.{{.RootFieldName}} {
		if _, exists := originalData[key]; !exists {
			t.Errorf("Key %q exists in deserialized but not in original data", key)
		}
	}
	
	// Verify that the data structures are not nil for a sample of keys
	// This ensures the deserialization created valid struct instances
	sampleKeys := []string{}
	for key := range originalData {
		if len(sampleKeys) >= 5 {
			break
		}
		sampleKeys = append(sampleKeys, key)
	}
	
	for _, key := range sampleKeys {
		original := originalData[key]
		deserialized := deserializedRoot.{{.RootFieldName}}[key]
		
		if original == nil && deserialized != nil {
			t.Errorf("Key %q: original is nil but deserialized is not", key)
		}
		if original != nil && deserialized == nil {
			t.Errorf("Key %q: original is not nil but deserialized is nil", key)
		}
		if original == nil || deserialized == nil {
			continue
		}
		
		// Re-serialize both to JSON and compare bytes to ensure structural equality
		originalBytes, err := json.Marshal(original)
		if err != nil {
			t.Errorf("Key %q: failed to marshal original: %v", key, err)
			continue
		}
		
		deserializedBytes, err := json.Marshal(deserialized)
		if err != nil {
			t.Errorf("Key %q: failed to marshal deserialized: %v", key, err)
			continue
		}
		
		// Compare JSON representations (normalized)
		var originalJSON, deserializedJSON interface{}
		if err := json.Unmarshal(originalBytes, &originalJSON); err != nil {
			t.Errorf("Key %q: failed to unmarshal original JSON: %v", key, err)
			continue
		}
		if err := json.Unmarshal(deserializedBytes, &deserializedJSON); err != nil {
			t.Errorf("Key %q: failed to unmarshal deserialized JSON: %v", key, err)
			continue
		}
		
		// Re-marshal both to normalized JSON for comparison
		originalNormalized, _ := json.Marshal(originalJSON)
		deserializedNormalized, _ := json.Marshal(deserializedJSON)
		
		if string(originalNormalized) != string(deserializedNormalized) {
			t.Errorf("Key %q: data mismatch after round-trip serialization", key)
		}
	}
}
