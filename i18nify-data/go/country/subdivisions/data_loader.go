// Code generated by i18nify go generator. DO NOT EDIT.

package country_subdivisions

import (
	"embed"
	"encoding/json"
	"fmt"
	"path/filepath"
	"strings"
	"sync"
)

//go:embed data/*.json
var dataFS embed.FS

var (
	cache     = make(map[string]*CountrySubdivisions)
	cacheLock sync.RWMutex
)

// GetCountrySubdivisions retrieves data for a specific country code.
// The country code is case-insensitive and will be converted to uppercase.
func GetCountrySubdivisions(countryCode string) (*CountrySubdivisions, error) {
	code := strings.ToUpper(countryCode)

	// Check cache first
	cacheLock.RLock()
	if data, ok := cache[code]; ok {
		cacheLock.RUnlock()
		return data, nil
	}
	cacheLock.RUnlock()

	// Load from embedded filesystem
	filePath := filepath.Join("data", code+".json")
	content, err := dataFS.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read data for country %s: %w", code, err)
	}

	var data CountrySubdivisions
	if err := json.Unmarshal(content, &data); err != nil {
		return nil, fmt.Errorf("failed to parse data for country %s: %w", code, err)
	}

	// Store in cache
	cacheLock.Lock()
	cache[code] = &data
	cacheLock.Unlock()

	return &data, nil
}

// GetAvailableCountryCodes returns a list of available country codes.
func GetAvailableCountryCodes() ([]string, error) {
	entries, err := dataFS.ReadDir("data")
	if err != nil {
		return nil, fmt.Errorf("failed to read data directory: %w", err)
	}

	var codes []string
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".json") {
			code := strings.TrimSuffix(entry.Name(), ".json")
			codes = append(codes, code)
		}
	}
	return codes, nil
}
