const fs = require('fs');
const path = require('path');

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function toCamelCase(str) {
  return str.replace(/[-_]([a-z])/g, g => g[1].toUpperCase());
}

function toPascalCase(str) {
  const camel = toCamelCase(str);
  return capitalize(camel);
}

function getGoType(schema) {
  if (schema.type === 'string') return 'string';
  if (schema.type === 'number') return 'float64';
  if (schema.type === 'integer') return 'int';
  if (schema.type === 'boolean') return 'bool';
  if (schema.type === 'array') {
    return `[]${getGoType(schema.items)}`;
  }
  if (schema.type === 'object') {
    return 'map[string]interface{}';
  }
  return 'interface{}';
}

function generateStructFromSchema(schema, structName) {
  let result = [];
  
  if (schema.type === 'object' && schema.properties) {
    result.push(`// ${structName} represents the generated structure from schema`);
    result.push(`type ${structName} struct {`);
    
    for (const [prop, propSchema] of Object.entries(schema.properties)) {
      const fieldName = toPascalCase(prop);
      let goType;
      
      if (propSchema.type === 'object' && propSchema.properties) {
        // Generate nested struct
        const nestedStructName = `${structName}${fieldName}`;
        const nestedStruct = generateStructFromSchema(propSchema, nestedStructName);
        result = [...nestedStruct, ...result];
        goType = nestedStructName;
      } else if (propSchema.patternProperties) {
        // Handle pattern properties as a map
        const valueSchema = Object.values(propSchema.patternProperties)[0];
        if (valueSchema.type === 'object') {
          const nestedStructName = `${structName}${fieldName}Item`;
          const nestedStruct = generateStructFromSchema(valueSchema, nestedStructName);
          result = [...nestedStruct, ...result];
          goType = `map[string]${nestedStructName}`;
        } else {
          goType = `map[string]${getGoType(valueSchema)}`;
        }
      } else {
        goType = getGoType(propSchema);
      }
      
      result.push(`    ${fieldName} ${goType} \`json:"${prop}"\``);
    }
    
    result.push('}');
    result.push('');
  }
  
  return result;
}

function generateGoCode(schemaPath, dataPath) {
  const schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));
  const data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
  
  const moduleName = path.basename(path.dirname(schemaPath));
  const structName = toPascalCase(moduleName + 'Data');
  
  const structures = generateStructFromSchema(schema, structName);
  
  const goCode = `// Code generated by generateGoFromSchema.js. DO NOT EDIT.
  package ${moduleName}

  ${structures.join('\n')}

  // ${structName}Instance contains the generated data
  var ${structName}Instance = ${JSON.stringify(data, null, 2)}
  `;
  
  const goFilePath = path.join('packages', 'i18nify-go', 'modules', moduleName, `${moduleName}.go`);
  
  // Ensure directory exists
  fs.mkdirSync(path.dirname(goFilePath), { recursive: true });
  
  // Write the generated code
  fs.writeFileSync(goFilePath, goCode);
  
  console.log(`Generated Go code for ${moduleName} at ${goFilePath}`);
}

// Main execution
if (require.main === module) {
  const schemaPath = process.env.SCHEMA_PATH;
  if (schemaPath) {
    const dataPath = path.join(path.dirname(schemaPath), 'data.json');
    generateGoCode(schemaPath, dataPath);
  } else {
    const baseDir = 'i18nify-data';
    const dirs = fs.readdirSync(baseDir).filter(dir => 
      fs.statSync(path.join(baseDir, dir)).isDirectory()
    );
    
    for (const dir of dirs) {
      const schemaFile = path.join(baseDir, dir, 'schema.json');
      const dataFile = path.join(baseDir, dir, 'data.json');
      
      if (fs.existsSync(schemaFile) && fs.existsSync(dataFile)) {
        generateGoCode(schemaFile, dataFile);
      }
    }
  }
}

module.exports = {
  generateGoCode,
  generateStructFromSchema,
  getGoType,
  toPascalCase,
  toCamelCase,
  capitalize
};