#!/usr/bin/env bash

# Test File Generator for i18nify-data Go packages
# 
# This script generates data_loader_test.go for a Go package.
# It creates tests that verify the data can be loaded correctly.
#
# Usage: ./generate-test.sh <output-dir> <package-name> <root-message> <multiple-files>
# Example: ./generate-test.sh ./output currency CurrencyData false
#
# Parameters:
#   output-dir     - Directory where test file will be created
#   package-name   - Go package name (e.g., currency, country_subdivisions)
#   root-message   - Proto root message name (e.g., CurrencyData, BankCodes)
#   multiple-files - "true" for multi-file packages, "false" for single-file

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m'

log_info() { echo -e "${GREEN}[INFO]${NC} $1" >&2; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

# --- Parse Arguments ---
OUTPUT_DIR="${1:-}"
GO_PACKAGE_NAME="${2:-}"
ROOT_MESSAGE="${3:-}"
MULTIPLE_FILES="${4:-false}"

if [ -z "$OUTPUT_DIR" ] || [ -z "$GO_PACKAGE_NAME" ] || [ -z "$ROOT_MESSAGE" ]; then
    log_error "Missing required arguments"
    echo "Usage: $0 <output-dir> <package-name> <root-message> <multiple-files>"
    echo "Example: $0 ./output currency CurrencyData false"
    exit 1
fi

log_info "Generating test file..."
log_info "  Output dir: $OUTPUT_DIR"
log_info "  Package: $GO_PACKAGE_NAME"
log_info "  Root message: $ROOT_MESSAGE"
log_info "  Multiple files: $MULTIPLE_FILES"

# --- Ensure output directory exists ---
mkdir -p "$OUTPUT_DIR"

# --- Generate Test File ---
TEST_FILE="$OUTPUT_DIR/data_loader_test.go"

if [ "$MULTIPLE_FILES" = "true" ]; then
    # Generate multi-file data loader test
    cat > "$TEST_FILE" << TESTEOF
// Code generated by i18nify go generator. DO NOT EDIT.

package ${GO_PACKAGE_NAME}

import (
	"testing"
)

// TestGet${ROOT_MESSAGE}_AllCountryCodes tests that all available country codes
// can be loaded successfully. This ensures the JSON data is valid and matches
// the proto schema.
func TestGet${ROOT_MESSAGE}_AllCountryCodes(t *testing.T) {
	// Get all available country codes
	codes, err := GetAvailableCountryCodes()
	if err != nil {
		t.Fatalf("GetAvailableCountryCodes() error = %v", err)
	}

	if len(codes) == 0 {
		t.Fatal("GetAvailableCountryCodes() returned empty list")
	}

	t.Logf("Found %d country codes: %v", len(codes), codes)

	// Test loading data for each country code
	for _, code := range codes {
		t.Run(code, func(t *testing.T) {
			data, err := Get${ROOT_MESSAGE}(code)
			if err != nil {
				t.Errorf("Get${ROOT_MESSAGE}(%q) error = %v", code, err)
				return
			}
			if data == nil {
				t.Errorf("Get${ROOT_MESSAGE}(%q) returned nil data", code)
			}
		})
	}
}

// TestGet${ROOT_MESSAGE}_InvalidCode tests that an invalid country code
// returns an appropriate error.
func TestGet${ROOT_MESSAGE}_InvalidCode(t *testing.T) {
	_, err := Get${ROOT_MESSAGE}("INVALID_CODE_XYZ_123")
	if err == nil {
		t.Error("Get${ROOT_MESSAGE}(\"INVALID_CODE_XYZ_123\") expected error, got nil")
	}
}

// TestGet${ROOT_MESSAGE}_CaseInsensitive tests that country codes are
// handled case-insensitively.
func TestGet${ROOT_MESSAGE}_CaseInsensitive(t *testing.T) {
	codes, err := GetAvailableCountryCodes()
	if err != nil || len(codes) == 0 {
		t.Skip("No country codes available")
	}

	code := codes[0]
	
	// Test uppercase
	data1, err1 := Get${ROOT_MESSAGE}(code)
	if err1 != nil {
		t.Fatalf("Get${ROOT_MESSAGE}(%q) error = %v", code, err1)
	}

	// Test lowercase (should return same data from cache)
	lowerCode := code // codes are already uppercase
	data2, err2 := Get${ROOT_MESSAGE}(lowerCode)
	if err2 != nil {
		t.Fatalf("Get${ROOT_MESSAGE}(%q) error = %v", lowerCode, err2)
	}

	// Both should return valid data
	if data1 == nil || data2 == nil {
		t.Error("Expected non-nil data for both cases")
	}
}
TESTEOF
else
    # Generate single-file data loader test
    cat > "$TEST_FILE" << TESTEOF
// Code generated by i18nify go generator. DO NOT EDIT.

package ${GO_PACKAGE_NAME}

import (
	"testing"
)

// TestGet${ROOT_MESSAGE} tests that the data can be loaded successfully.
// This ensures the JSON data is valid and matches the proto schema.
func TestGet${ROOT_MESSAGE}(t *testing.T) {
	data, err := Get${ROOT_MESSAGE}()
	if err != nil {
		t.Fatalf("Get${ROOT_MESSAGE}() error = %v", err)
	}

	if data == nil {
		t.Fatal("Get${ROOT_MESSAGE}() returned nil data")
	}

	t.Log("Data loaded successfully")
}

// TestGet${ROOT_MESSAGE}_Idempotent tests that multiple calls return
// the same cached instance.
func TestGet${ROOT_MESSAGE}_Idempotent(t *testing.T) {
	// Call twice to verify caching works
	data1, err1 := Get${ROOT_MESSAGE}()
	if err1 != nil {
		t.Fatalf("First Get${ROOT_MESSAGE}() error = %v", err1)
	}

	data2, err2 := Get${ROOT_MESSAGE}()
	if err2 != nil {
		t.Fatalf("Second Get${ROOT_MESSAGE}() error = %v", err2)
	}

	// Should return the same pointer (cached)
	if data1 != data2 {
		t.Error("Get${ROOT_MESSAGE}() should return cached data on subsequent calls")
	}
}

// TestGet${ROOT_MESSAGE}_NotEmpty performs a basic sanity check
// that the loaded data is not empty.
func TestGet${ROOT_MESSAGE}_NotEmpty(t *testing.T) {
	data, err := Get${ROOT_MESSAGE}()
	if err != nil {
		t.Fatalf("Get${ROOT_MESSAGE}() error = %v", err)
	}

	// Use reflection or proto methods to check if data has any fields set
	// This is a basic check - specific packages may want more detailed validation
	if data == nil {
		t.Error("Data should not be nil")
	}
}
TESTEOF
fi

log_info "âœ… Generated: $TEST_FILE"
echo "$TEST_FILE"
