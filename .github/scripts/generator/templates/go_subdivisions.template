// CODE GENERATED. DO NOT EDIT.
package {{.PackageName}}

import (
	"embed"
	"encoding/json"
	"fmt"
	"path/filepath"
	"sync"
)

//go:embed data
var dataFS embed.FS

var (
	dataOnce sync.Once
	dataCache map[string]*{{.StructName}}
	cacheMutex sync.RWMutex
)

// GetCountrySubdivisions returns the subdivisions data for a specific country code.
func GetCountrySubdivisions(countryCode string) (*{{.StructName}}, error) {
	// Initialize cache on first call
	dataOnce.Do(func() {
		dataCache = make(map[string]*{{.StructName}})
	})

	// Check cache first
	cacheMutex.RLock()
	if cached, exists := dataCache[countryCode]; exists {
		cacheMutex.RUnlock()
		return cached, nil
	}
	cacheMutex.RUnlock()

	// Load from embedded filesystem
	filePath := filepath.Join("data", countryCode+".json")
	jsonBytes, err := dataFS.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read embedded {{.DataContext}} data for country %s: %w", countryCode, err)
	}

	// Use a temporary struct to handle the "region_name/district_name" JSON field
	// since protobuf doesn't support special characters in JSON field names
	type tempCity struct {
		Name       string   `json:"name"`
		RegionName string   `json:"region_name/district_name"`
		Timezone   string   `json:"timezone"`
		Zipcodes   []string `json:"zipcodes"`
	}
	type tempState struct {
		Name   string              `json:"name"`
		Cities map[string]tempCity `json:"cities"`
	}
	type tempSubdivisions struct {
		CountryName string              `json:"country_name"`
		States      map[string]tempState `json:"states"`
	}

	var tempData tempSubdivisions
	if err := json.Unmarshal(jsonBytes, &tempData); err != nil {
		return nil, fmt.Errorf("failed to parse embedded {{.DataContext}} data for country %s: %w", countryCode, err)
	}

	// Convert temp struct to proto struct
	subdivisions := {{.StructName}}{
		CountryName: tempData.CountryName,
		States:      make(map[string]*State),
	}
	for stateCode, tempState := range tempData.States {
		state := &State{
			Name:   tempState.Name,
			Cities: make(map[string]*City),
		}
		for cityName, tempCity := range tempState.Cities {
			state.Cities[cityName] = &City{
				Name:       tempCity.Name,
				RegionName: tempCity.RegionName,
				Timezone:   tempCity.Timezone,
				Zipcodes:   tempCity.Zipcodes,
			}
		}
		subdivisions.States[stateCode] = state
	}

	// Cache the result
	cacheMutex.Lock()
	dataCache[countryCode] = &subdivisions
	cacheMutex.Unlock()

	return &subdivisions, nil
}

