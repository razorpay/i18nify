{"version":3,"file":"index.min.js","sources":["../../src/common/errorBoundary/index.ts","../../src/modules/.internal/state/index.ts","../../src/modules/.internal/utils/getDefaultState.ts","../../src/modules/core/getState.ts","../../src/modules/core/setState.ts","../../src/modules/core/resetState.ts","../../src/modules/.internal/utils/getLocale.ts","../../src/modules/.internal/utils/getIntlInstanceWithOptions.ts","../../src/modules/currency/formatNumber.ts","../../src/modules/currency/data/currencies.ts","../../src/modules/currency/getCurrencyList.ts","../../src/modules/currency/getCurrencySymbol.ts","../../src/modules/currency/constants.ts","../../src/modules/currency/formatNumberByParts.ts","../../src/modules/phoneNumber/data/phoneRegexMapper.ts","../../src/modules/phoneNumber/data/dialCodeMapper.ts","../../src/modules/phoneNumber/utils.ts","../../src/modules/phoneNumber/isValidPhoneNumber.ts","../../src/modules/phoneNumber/data/phoneFormatterMapper.ts","../../src/modules/phoneNumber/formatPhoneNumber.ts","../../src/modules/phoneNumber/parsePhoneNumber.ts","../../src/modules/dateTime/utils.ts","../../src/modules/dateTime/add.ts","../../src/modules/dateTime/formatDateTime.ts","../../src/modules/dateTime/formatDate.ts","../../src/modules/dateTime/formatTime.ts","../../src/modules/dateTime/getFirstDayOfWeek.ts","../../src/modules/dateTime/getQuarter.ts","../../src/modules/dateTime/getRelativeTime.ts","../../src/modules/dateTime/getWeek.ts","../../src/modules/dateTime/getWeekdays.ts","../../src/modules/dateTime/isAfter.ts","../../src/modules/dateTime/isBefore.ts","../../src/modules/dateTime/isLeapYear.ts","../../src/modules/dateTime/isSameDay.ts","../../src/modules/dateTime/isValidDate.ts","../../src/modules/dateTime/data/localeDateFormats.ts","../../src/modules/dateTime/parseDateWithFormat.ts","../../src/modules/dateTime/parseDate.ts","../../src/modules/dateTime/subtract.ts"],"sourcesContent":["// Custom Error class to extend properties to error object\nexport class I18nifyError extends Error {\n  timestamp: Date;\n  constructor(message: string | undefined) {\n    super(message);\n    this.name = 'i18nify Error';\n    this.timestamp = new Date();\n    // more params like type of error/severity can be added in future for better debugging.\n  }\n}\n\n/**\n * withErrorBoundary is a higher order function that takes function as parameter and wraps it in try/catch block.\n * It appends additional attributes and serves as a centralized error-handling service.\n * Usage =>\n * const wrappedUtilityFn = withErrorBoundary(utilityFn)\n *\n * @param fn utility that is wrapped in error boundary\n * @returns {Function} returns the function wrapped in try/catch block\n */\nexport const withErrorBoundary = <T extends (...args: any[]) => any>(\n  fn: T,\n): ((...args: Parameters<T>) => ReturnType<T>) => {\n  return function (this: unknown, ...rest: Parameters<T>): ReturnType<T> {\n    try {\n      return fn.call(this, ...rest) as ReturnType<T>;\n    } catch (err) {\n      console.warn('[I18N Error]: ', err);\n      // Currently, we are throwing the error as it is to consumers.\n      // In the future, this can be modified as per our requirement, like an error logging service.\n      throw new I18nifyError(err as string | undefined);\n    }\n  };\n};\n","import { I18nState } from './types';\nimport { getDefaultState } from '../utils/getDefaultState';\n\nexport class I18nStateManager {\n  private static instance: I18nStateManager | undefined;\n  private state: I18nState;\n\n  private constructor() {\n    this.state = getDefaultState();\n  }\n\n  public static getInstance(): I18nStateManager {\n    if (!I18nStateManager.instance) {\n      I18nStateManager.instance = new I18nStateManager();\n    }\n\n    return I18nStateManager.instance;\n  }\n\n  public static resetInstance(): void {\n    I18nStateManager.instance = undefined;\n  }\n\n  public getState(): I18nState {\n    return { ...this.state };\n  }\n\n  public setState(newState: Partial<I18nState>): void {\n    this.state = { ...this.state, ...newState };\n  }\n\n  public resetState(): void {\n    this.state = getDefaultState();\n  }\n}\n\nexport default I18nStateManager.getInstance();\n","import type { I18nState } from '../state/types';\n\nexport function getDefaultState(): I18nState {\n  return {\n    locale: '',\n    direction: '',\n    country: '',\n  };\n}\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport state from '../.internal/state';\nimport { I18nState } from '../.internal/state/types';\n\n/**\n * function to return active i18n state\n *\n *  ===== USAGE =====\n * import { getState } from '@razorpay/i18nify-js';\n *\n * console.log(getState())\n *\n * @returns i18n state\n */\nconst getState = (): I18nState => {\n  return state.getState();\n};\n\nexport default withErrorBoundary<typeof getState>(getState);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport state from '../.internal/state';\nimport { I18nState } from '../.internal/state/types';\n\n/**\n * Function to set and override the active state in i18nify SDK\n *\n * ===== USAGE =====\n * import { setState } from \"@razorpay/i18nify-js\";\n * setState({locale: 'en-US'})\n *\n * @param newState data to set in i18nState instance\n */\nconst setState = (newState: Partial<I18nState>): void => {\n  state.setState(newState);\n};\n\nexport default withErrorBoundary<typeof setState>(setState);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport state from '../.internal/state';\n\n/**\n * Function to reset the active state in i18nify SDK\n *\n * ===== USAGE =====\n * import { resetState } from \"@razorpay/i18nify-js\";\n * resetState()\n *\n * @param newState data to set in i18nState instance\n */\nconst resetState = (): void => {\n  state.resetState();\n};\n\nexport default withErrorBoundary<typeof resetState>(resetState);\n","export const getLocale = (): string => {\n  // Check if running in a non-browser environment (e.g., Node.js or older browsers).\n  if (typeof navigator === 'undefined') {\n    return 'en-IN';\n  }\n\n  // Check if the browser supports the Intl object and user language preferences.\n  if (\n    window.Intl &&\n    typeof window.Intl === 'object' &&\n    (window.navigator.languages || window.navigator.language)\n  ) {\n    const userLocales = window.navigator.languages || [\n      window.navigator.language,\n    ];\n    return userLocales[0];\n  }\n\n  // Fallback to a supported locale or the default locale.\n  return 'en-IN';\n};\n","import { CURRENCIES } from '../../currency/data/currencies';\nimport state from '../state';\nimport { getLocale } from './getLocale';\n\nexport const getIntlInstanceWithOptions = (\n  options: {\n    currency?: keyof typeof CURRENCIES;\n    locale?: string;\n    intlOptions?: Intl.NumberFormatOptions;\n  } = {},\n) => {\n  /** retrieve locale from below areas in order of preference\n   * 1. options.locale (used in case if someone wants to override locale just for a specific area and not globally)\n   * 2. i18nState.locale (uses locale set globally)\n   * 3. navigator (in case locale is not passed or set, use it from browser's navigator)\n   * */\n  let locale = options?.locale || state.getState().locale;\n\n  // If a specific locale is provided, use it; otherwise, use the browser's locale\n  if (!locale) {\n    locale = getLocale();\n  }\n\n  const intlOptions = options?.intlOptions ? { ...options.intlOptions } : {};\n\n  if (options?.currency || intlOptions.currency) {\n    intlOptions.style = 'currency';\n    intlOptions.currency = (options.currency || intlOptions.currency) as string;\n  }\n\n  if (!locale) throw new Error('Pass valid locale !');\n\n  return new Intl.NumberFormat(locale || undefined, intlOptions);\n};\n","import { CURRENCIES } from './data/currencies';\nimport { withErrorBoundary } from '../../common/errorBoundary';\nimport { getIntlInstanceWithOptions } from '../.internal/utils';\n\n// this function formats number based on different arguments passed\nconst formatNumber = (\n  amount: string | number,\n  options: {\n    currency?: keyof typeof CURRENCIES;\n    locale?: string;\n    intlOptions?: Intl.NumberFormatOptions;\n  } = {},\n): string => {\n  if (!Number(amount) && Number(amount) !== 0)\n    throw new Error('Parameter `amount` is not a number!');\n\n  let formattedAmount = '';\n\n  try {\n    formattedAmount = getIntlInstanceWithOptions(options).format(\n      Number(amount),\n    );\n  } catch (err) {\n    if (err instanceof Error) {\n      throw new Error(err.message);\n    } else {\n      throw new Error(`An unknown error occurred = ${err}`);\n    }\n  }\n\n  return formattedAmount;\n};\n\nexport default withErrorBoundary<typeof formatNumber>(formatNumber);\n","export const CURRENCIES: { [key: string]: { symbol: string; name: string } } = {\n  AED: { symbol: 'د.إ', name: 'United Arab Emirates Dirham' },\n  ALL: { symbol: 'Lek', name: 'Albanian Lek' },\n  AMD: { symbol: '֏', name: 'Armenian Dram' },\n  ARS: { symbol: 'ARS', name: 'Argentine Peso' },\n  AUD: { symbol: 'A$', name: 'Australian Dollar' },\n  AWG: { symbol: 'Afl.', name: 'Aruban Florin' },\n  BBD: { symbol: '$', name: 'Barbadian Dollar' },\n  BDT: { symbol: '৳', name: 'Bangladeshi Taka' },\n  BMD: { symbol: '$', name: 'Bermudian Dollar' },\n  BND: { symbol: 'BND', name: 'Brunei Dollar' },\n  BOB: { symbol: 'Bs', name: 'Bolivian Boliviano' },\n  BSD: { symbol: 'B$', name: 'Bahamian Dollar' },\n  BWP: { symbol: 'P', name: 'Botswanan Pula' },\n  BZD: { symbol: 'BZ$', name: 'Belize Dollar' },\n  CAD: { symbol: 'C$', name: 'Canadian Dollar' },\n  CHF: { symbol: 'CHf', name: 'Swiss Franc' },\n  CNY: { symbol: '¥', name: 'Chinese Yuan' },\n  COP: { symbol: 'COL$', name: 'Colombian Peso' },\n  CRC: { symbol: '₡', name: 'Costa Rican Colón' },\n  CUP: { symbol: '$MN', name: 'Cuban Peso' },\n  CZK: { symbol: 'Kč', name: 'Czech Koruna' },\n  DKK: { symbol: 'DKK', name: 'Danish Krone' },\n  DOP: { symbol: 'RD$', name: 'Dominican Peso' },\n  DZD: { symbol: 'د.ج', name: 'Algerian Dinar' },\n  EGP: { symbol: 'E£', name: 'Egyptian Pound' },\n  ETB: { symbol: 'ብር', name: 'Ethiopian Birr' },\n  EUR: { symbol: '€', name: 'Euro' },\n  FJD: { symbol: 'FJ$', name: 'Fijian Dollar' },\n  GBP: { symbol: '£', name: 'British Pound' },\n  GHS: { symbol: 'GH₵', name: 'Ghanaian Cedi' },\n  GIP: { symbol: 'GIP', name: 'Gibraltar Pound' },\n  GMD: { symbol: 'D', name: 'Gambian Dalasi' },\n  GTQ: { symbol: 'Q', name: 'Guatemalan Quetzal' },\n  GYD: { symbol: 'G$', name: 'Guyanese Dollar' },\n  HKD: { symbol: 'HK$', name: 'Hong Kong Dollar' },\n  HNL: { symbol: 'HNL', name: 'Honduran Lempira' },\n  HRK: { symbol: 'kn', name: 'Croatian Kuna' },\n  HTG: { symbol: 'G', name: 'Haitian Gourde' },\n  HUF: { symbol: 'Ft', name: 'Hungarian Forint' },\n  IDR: { symbol: 'Rp', name: 'Indonesian Rupiah' },\n  ILS: { symbol: '₪', name: 'Israeli New Shekel' },\n  INR: { symbol: '₹', name: 'Indian Rupee' },\n  JMD: { symbol: 'J$', name: 'Jamaican Dollar' },\n  KES: { symbol: 'Ksh', name: 'Kenyan Shilling' },\n  KGS: { symbol: 'Лв', name: 'Kyrgystani Som' },\n  KHR: { symbol: '៛', name: 'Cambodian Riel' },\n  KYD: { symbol: 'CI$', name: 'Cayman Islands Dollar' },\n  KZT: { symbol: '₸', name: 'Kazakhstani Tenge' },\n  LAK: { symbol: '₭', name: 'Laotian Kip' },\n  LKR: { symbol: 'රු', name: 'Sri Lankan Rupee' },\n  LRD: { symbol: 'L$', name: 'Liberian Dollar' },\n  LSL: { symbol: 'LSL', name: 'Lesotho Loti' },\n  MAD: { symbol: 'د.م.', name: 'Moroccan Dirham' },\n  MDL: { symbol: 'MDL', name: 'Moldovan Leu' },\n  MKD: { symbol: 'ден', name: 'Macedonian Denar' },\n  MMK: { symbol: 'MMK', name: 'Myanmar Kyat' },\n  MNT: { symbol: '₮', name: 'Mongolian Tugrik' },\n  MOP: { symbol: 'MOP$', name: 'Macanese Pataca' },\n  MUR: { symbol: '₨', name: 'Mauritian Rupee' },\n  MVR: { symbol: 'Rf', name: 'Maldivian Rufiyaa' },\n  MWK: { symbol: 'MK', name: 'Malawian Kwacha' },\n  MXN: { symbol: 'Mex$', name: 'Mexican Peso' },\n  MYR: { symbol: 'RM', name: 'Malaysian Ringgit' },\n  NAD: { symbol: 'N$', name: 'Namibian Dollar' },\n  NGN: { symbol: '₦', name: 'Nigerian Naira' },\n  NIO: { symbol: 'NIO', name: 'Nicaraguan Córdoba' },\n  NOK: { symbol: 'NOK', name: 'Norwegian Krone' },\n  NPR: { symbol: 'रू', name: 'Nepalese Rupee' },\n  NZD: { symbol: 'NZ$', name: 'New Zealand Dollar' },\n  PEN: { symbol: 'S/', name: 'Peruvian Nuevo Sol' },\n  PGK: { symbol: 'PGK', name: 'Papua New Guinean Kina' },\n  PHP: { symbol: '₱', name: 'Philippine Peso' },\n  PKR: { symbol: '₨', name: 'Pakistani Rupee' },\n  QAR: { symbol: 'QR', name: 'Qatari Riyal' },\n  RUB: { symbol: '₽', name: 'Russian Ruble' },\n  SAR: { symbol: 'SR', name: 'Saudi Riyal' },\n  SCR: { symbol: 'SRe', name: 'Seychellois Rupee' },\n  SEK: { symbol: 'SEK', name: 'Swedish Krona' },\n  SGD: { symbol: 'S$', name: 'Singapore Dollar' },\n  SLL: { symbol: 'Le', name: 'Sierra Leonean Leone' },\n  SOS: { symbol: 'Sh.so.', name: 'Somali Shilling' },\n  SSP: { symbol: 'SS£', name: 'South Sudanese Pound' },\n  SVC: { symbol: '₡', name: 'Salvadoran Colón' },\n  SZL: { symbol: 'E', name: 'Swazi Lilangeni' },\n  THB: { symbol: '฿', name: 'Thai Baht' },\n  TTD: { symbol: 'TT$', name: 'Trinidad and Tobago Dollar' },\n  TZS: { symbol: 'Sh', name: 'Tanzanian Shilling' },\n  USD: { symbol: '$', name: 'United States Dollar' },\n  UYU: { symbol: '$U', name: 'Uruguayan Peso' },\n  UZS: { symbol: \"so'm\", name: 'Uzbekistani Som' },\n  YER: { symbol: '﷼', name: 'Yemeni Rial' },\n  ZAR: { symbol: 'R', name: 'South African Rand' },\n  KWD: { symbol: 'د.ك', name: 'Kuwaiti Dinar' },\n  BHD: { symbol: 'د.ب.', name: 'Bahraini Dinar' },\n  OMR: { symbol: 'ر.ع.', name: 'Omani Rial' },\n};\n","import { CURRENCIES } from './data/currencies';\nimport { withErrorBoundary } from '../../common/errorBoundary';\n\nconst getCurrencyList = () => {\n  return CURRENCIES;\n};\n\nexport default withErrorBoundary<typeof getCurrencyList>(getCurrencyList);\n","import { CURRENCIES } from './data/currencies';\nimport { withErrorBoundary } from '../../common/errorBoundary';\n\nconst getCurrencySymbol = (currencyCode: keyof typeof CURRENCIES): string => {\n  if (currencyCode in CURRENCIES) return CURRENCIES[currencyCode]?.symbol;\n  else throw new Error('Invalid currencyCode!');\n};\n\nexport default withErrorBoundary<typeof getCurrencySymbol>(getCurrencySymbol);\n","export const ALLOWED_FORMAT_PARTS_KEYS = [\n  'nan',\n  'infinity',\n  'percent',\n  'integer',\n  'group',\n  'decimal',\n  'fraction',\n  'plusSign',\n  'minusSign',\n  'percentSign',\n  'currency',\n  'code',\n  'symbol',\n  'name',\n  'compact',\n  'exponentInteger',\n  'exponentMinusSign',\n  'exponentSeparator',\n  'unit',\n] as const;\n","import { CURRENCIES } from './data/currencies';\nimport { ByParts, FormattedPartsObject } from './types';\nimport { withErrorBoundary } from '../../common/errorBoundary';\nimport { getIntlInstanceWithOptions } from '../.internal/utils';\nimport { ALLOWED_FORMAT_PARTS_KEYS } from './constants';\n\nconst formatNumberByParts = (\n  amount: string | number,\n  options: {\n    currency?: keyof typeof CURRENCIES;\n    locale?: string;\n    intlOptions?: Intl.NumberFormatOptions;\n  } = {},\n): ByParts => {\n  if (!Number(amount) && Number(amount) !== 0)\n    throw new Error('Parameter `amount` is not a number!');\n\n  try {\n    const formattedAmount = getIntlInstanceWithOptions(options).formatToParts(\n      Number(amount),\n    );\n\n    const parts = formattedAmount;\n\n    const formattedObj: FormattedPartsObject = {};\n\n    parts.forEach((p) => {\n      if (p.type === 'group') {\n        formattedObj.integer = (formattedObj.integer || '') + p.value;\n      } else if (\n        ALLOWED_FORMAT_PARTS_KEYS.findIndex((item) => item === p.type) != -1\n      ) {\n        // @ts-expect-error only allowed keys are added to the formattedObj. For eg, key 'literal' is skipped\n        formattedObj[p.type] = (formattedObj[p.type] || '') + p.value;\n      }\n    });\n\n    return {\n      ...formattedObj,\n      isPrefixSymbol: parts[0].type === 'currency',\n      rawParts: parts,\n    };\n  } catch (err) {\n    if (err instanceof Error) {\n      throw new Error(err.message);\n    } else {\n      throw new Error(`An unknown error occurred = ${err}`);\n    }\n  }\n};\n\nexport default withErrorBoundary<typeof formatNumberByParts>(\n  formatNumberByParts,\n);\n","export const PHONE_REGEX_MAPPER: { [key: string]: RegExp } = {\n  IN: /^(?:(?:\\+|0{0,2})91\\s*[-]?\\s*|[0]?)?[6789]\\d{9}$/,\n  MY: /^(\\+?6?0)?(\\d{1,3})[-. ]?(\\d{7,8})$/,\n  AE: /^(?:\\+?971|0)?(?:2|3|4|6|7|9)\\d{8}$/,\n  AL: /^(?:\\+?355)?(?:[4-9]\\d{7}|6\\d{8})$/,\n  AM: /^(?:\\+?374)?(?:[0-9]{8}|[0-9]{6}[0-9]{2})$/,\n  AR: /^(?:(?:\\+|0{0,2})54)?(?:11|[2368]\\d)(?:(?=\\d{0,2}15)\\d{2})??\\d{8}$/,\n  AU: /^(?:\\+?61|0)4\\d{8}$/,\n  AW: /^(?:(?:\\+297)?(?!0)\\d{7})$/,\n  BB: /^(?:(?:\\+1)?246)?(?:\\d{3})?\\d{7}$/,\n  BD: /^(?:\\+?880|0)1[13456789]\\d{8}$/,\n  BM: /^(?:(?:\\+1)?441)?(?:\\d{2})?\\d{7}$/,\n  BN: /^(?:\\+?673)?(?:\\d{3})?\\d{4}$/,\n  BO: /^(?:(?:\\+|0{0,2})591)?(?:(?:2|3|7|6)\\d{7})$/,\n  BS: /^(?:(?:\\+1)?242)?(?:\\d{3})?\\d{7}$/,\n  BW: /^(?:(?:\\+267)?\\s?)?[74]\\d{7}$/,\n  BZ: /^(?:(?:\\+501)?\\s?)?[622]\\d{4}$/,\n  CH: /^(?:(?:\\+41|0)(?:\\s*\\(?0\\)?\\s*))?(?:\\d{2}\\s*)?\\d{3}\\s*\\d{2}\\s*\\d{2}$/,\n  CN: /^(?:(?:\\+|00)86)?1\\d{10}$/,\n  CO: /^(?:(?:\\+57|0057)?)?[1-8]{1}\\d{6,7}$/,\n  OM: /^(?:\\+?968)?(?:95|96|97|98)\\d{6}$/,\n  CR: /^(?:(?:\\+506)?\\s*|0)?[1-9]\\d{7}$/,\n  CU: /^(?:\\+?53)?(?:[5-8]\\d{7})$/,\n  CZ: /^(?:\\+?420)?(?:\\d{9})$/,\n  DK: /^(?:\\+?45)?(?:\\d{8})$/,\n  DO: /^(?:(?:\\+1)?809|1-8(?:00|88|89))(?:\\d{7})$/,\n  DZ: /^(?:\\+?213|0)([567]\\d{8})$/,\n  EG: /^(?:(?:\\+20|20)?(\\d{10}))$/,\n  ET: /^(?:\\+?251)?[1-59]\\d{8}$/,\n  EU: /^(?:(?:\\+?3)?8)?\\s*(?:\\d{3}\\s*){3}\\d{2}$/,\n  FJ: /^(?:(?:\\+?679)?\\s?\\d{3}\\s?\\d{4})?$/,\n  GB: /^(?:(?:\\+44\\s?|0)7\\d{3}(\\s?\\d{4,})?)$/,\n  GH: /^(?:(?:\\+233)|0)?(?:\\d{9})$/,\n  GI: /^(?:\\+350)?\\d{5}$/,\n  GM: /^(?:\\+220)?\\d{5,7}$/,\n  GT: /^(?:\\+502)?[2468]\\d{7,8}$/,\n  GY: /^(?:(?:\\+592)?(?:(?:\\s)?[2-9])(?:(?:\\s)?\\d))?(?:(?:\\s)?\\d{4})$/,\n  HK: /^(?:\\+852\\s?)?[456789]\\d{3}\\s?\\d{4}$/,\n  HN: /^(?:\\+504)?[89]\\d{7}$/,\n  HR: /^(?:\\+?385)?\\d{8,9}$/,\n  HT: /^(?:\\+?509)?\\d{8}$/,\n  HU: /^(?:(?:\\+36))(\\s?\\d{2}\\s?\\d{3}\\s?\\d{4})$/,\n  ID: /^(?:\\+?62|0[1-9])[\\s-]?\\d{2,4}[\\s-]?\\d{3,4}[\\s-]?\\d{3,4}$/,\n  IL: /^(?:(?:\\+972|0)(?:-)?)[23489]\\d{7}$/,\n  JM: /^(?:(?:\\+1876))\\d{7,10}$/,\n  KE: /^(?:(?:\\+254)|(?:0))(?:\\d{6,7})$/,\n  KG: /^(?:\\+996)?\\s?\\d{9}$/,\n  KH: /^(?:(?:\\+855)|(?:0))(?:\\s?[1-9]\\d{7,8})$/,\n  KY: /^(?:\\+?1\\s?(345))\\d{6}$/,\n  KZ: /^(?:\\+?7|8)?7\\d{9}$/,\n  LA: /^(?:(?:\\+?856)|0)(20\\d{7,9})$/,\n  LK: /^(?:(?:\\+94)|0)(?:\\d{9})$/,\n  LR: /^(?:\\+231)[ -\\d]{4}[ -\\d]{4}$/,\n  LS: /^(?:(?:\\+?266)|0)?[56]\\d{7}$/,\n  MA: /^(?:(?:\\+?212(\\s*[-|\\s*]?\\d{1,9})?)|(?:0))(?:\\d{9})$/,\n  MD: /^(?:(?:\\+373)|(?:0))(?:\\d{7,8})$/,\n  MK: /^(?:\\+389|0)(?:(?:2[0-4]|[3-9])\\s?)?\\d{6}$/,\n  MM: /^(?:(?:\\+?95)|0)?[1-9]\\d{9}$/,\n  MN: /^(?:\\+976|0)\\d{8}$/,\n  MO: /^(?:(?:\\+?853)|[0-9])?\\d{8}$/,\n  MU: /^(?:\\+230|0)?\\d{8}$/,\n  MV: /^(?:(?:\\+?960)|0)?\\d{7}$/,\n  MW: /^(?:\\+265)[1-9]\\d{6}$/,\n  MX: /^(?:(?:\\+?52)?\\s?(?:1|01)?\\s?)?(?:\\d{3}\\s?\\d{3}\\s?\\d{4})$/,\n  NA: /^(?:(?:\\+264)|0)?\\d{8}$/,\n  NG: /^(?:(?:\\+234)|(?:0))(?:\\d{7,8})$/,\n  NI: /^(?:(?:\\+505))?(?:\\d{8})$/,\n  NO: /^(?:(?:\\+?47)|\\d{2}|\\d{3})\\s?\\d{2}\\s?\\d{3}$/,\n  NP: /^(?:(?:\\+977))?(\\d{9,10})$/,\n  NZ: /^(?:\\+?64|0)(\\d{2,5} \\d{4,8}|\\d{3,4} \\d{4})$/,\n  PE: /^(?:(?:\\+51)|0)?(?:9\\d{8})$/,\n  PG: /^(?:\\+?675)?(?:[7-9]\\d{7})$/,\n  PH: /^(?:(?:\\+?63)|0)(?:\\d{10})$/,\n  PK: /^(?:(?:\\+92)|0)?[345]\\d{9}$/,\n  QA: /^(?:\\+?974)?-?33\\d{5}$/,\n  RU: /^(?:\\+?7|8)?[ -]?\\(?9\\d{2}\\)?[ -]?\\d{3}[ -]?\\d{2}[ -]?\\d{2}$/,\n  SA: /^(?:\\+?966)?\\s?1?[\\s-]?(?:[45]\\d{2}|5\\d{3})[\\s-]?\\d{4}$/,\n  SC: /^(?:(?:\\+248)|\\d{4})\\d{5}$/,\n  SE: /^(?:\\+?46|0)\\s?[1-57-9](?:[0-9]\\s?){8}$/,\n  SG: /^(?:(?:\\+65)|(?:\\(\\+65\\))|(?:65))\\d{4}\\d{4}$/,\n  SL: /^(?:(?:\\+232)|(?:0))?\\d{9}$/,\n  SO: /^(?:\\+252|0)?[567]\\d{7}$/,\n  SS: /^(?:\\+211|0)?[1-9]\\d{7,9}$/,\n  SV: /^(?:(?:\\+?503)|(?:0))(?:\\d{8})$/,\n  SZ: /^(?:\\+?268)?\\d{7,8}$/,\n  TH: /^(?:(?:\\+66)|0)\\d{9}$/,\n  TT: /^(?:(?:\\+?1-868)|\\(?868\\)?)(\\d{7})$/,\n  TZ: /^(?:(?:\\+?255)|0)?[67]\\d{8}$/,\n  US: /^(\\+\\d{1,2}\\s?)?([2-9]{1}\\d{2}[2-9]{1}\\d{6})$/,\n  CA: /^(\\+\\d{1,2}\\s?)?([2-9]{1}\\d{2}[2-9]{1}\\d{6})$/,\n  UY: /^(?:(?:\\+598|0)\\s?(9\\d{3}|2\\d{2}|[4-9]\\d{6}))$/,\n  UZ: /^(?:\\+?998)?\\s?[3456789]\\d{8}$/,\n  YE: /^(?:\\+?967)?(?:\\d{7,8})$/,\n  ZA: /^(?:(?:\\+27)|0)(\\d{9})$/,\n  KW: /^(?:\\+?965)[569]\\d{7}$/,\n  BH: /^(?:\\+?973)?[356]\\d{7}$/,\n  TL: /^(?:(?:\\+670)\\s?)?[0-9]{3}\\s?[0-9]{3,4}$/,\n  VC: /^(?:(?:\\+1)?784)?(?:\\d{3})?\\d{7}$/,\n  VE: /^(?:(?:\\+58)|0)?4\\d{9}$/,\n  VN: /^(?:(?:\\+84)|0)?[1-9]\\d{8}$/,\n  ZM: /^(?:(?:\\+260)|0)?[123456789]\\d{8,9}$/,\n  ZW: /^(?:(?:\\+263)|0)?(?:\\d{9,10})$/,\n  LT: /^(?:(?:\\+370)|8)\\d{8}$/,\n  LU: /^(?:(?:\\+352)?(6|2(6|7|8|9))\\d{6})$/,\n  LV: /^(?:(?:\\+371)?2\\d{7})$/,\n  ME: /^(?:(?:\\+382)?[67]\\d{7,20})$/,\n  MG: /^(?:(?:\\+261)?3[234568]\\d{7})$/,\n  MZ: /^(?:(?:\\+258)|(?:258))?8[234567]\\d{7,8}$/,\n  NL: /^(?:(?:\\+31)|0(6(?:\\d{8})|[1-9](?:(?:\\d{8})|(?:\\s\\d{3}\\s\\d{4}))|(?:\\d{8})))$/,\n  PA: /^(?:(?:\\+507)\\s?)?[46]\\d{6,7}$/,\n  PL: /^(?:(?:\\+48)?(?:\\s?\\d{3}\\s?\\d{3}\\s?\\d{3}|(?:\\d{2}\\s?){4}\\d{2}|\\d{3}-\\d{3}-\\d{3}))$/,\n  PR: /^(?:(?:\\+1)?787|939)\\d{7}$/,\n  PS: /^(?:(?:\\+970))(5[2349])\\d{7}$/,\n  PT: /^(?:(?:\\+351)?9(1\\d|2[1-9]|6[12345789]|7[12345789])\\d{7})$/,\n  PY: /^(?:(?:\\+595|0)9[9876]\\d{7})$/,\n  RO: /^(?:(?:\\+40|0))(?:7[2-8]\\d{7}|21\\d{8})$/,\n  RS: /^(?:(?:\\+381)|0)([0-6]|[7][012345])[0-9]{5,10}$/,\n  RW: /^(?:(?:\\+250)|(0))\\d{9}$/,\n  SI: /^(?:(?:\\+386)|0)?[1-59]\\d{7,8}$/,\n  SK: /^(?:(?:\\+421))?(0|9[0-8])\\d{8}$/,\n  SM: /^(?:(?:\\+378)|(0549|6\\d{4}))\\d{5}$/,\n  SN: /^(?:(?:\\+221)|0)?[3679]\\d{7}$/,\n  SR: /^(?:(?:\\+597))\\d{7}$/,\n  TG: /^(?:(?:\\+228))\\d{8}$/,\n  TJ: /^(?:(?:\\+992))(37|55|77)\\d{7}$/,\n  TN: /^(?:(?:\\+216)|22|9[1-9])\\d{7}$/,\n  TR: /^(?:(?:\\+90)|(0))\\s?5\\d{9}$/,\n  TW: /^(?:(?:\\+886)|0)?9\\d{8}$/,\n  UA: /^(?:(?:\\+380)|(0))?(39|50|63|66|67|68|91|92|93|94|95|96|97|98|99)\\d{7}$/,\n  UG: /^(?:(?:\\+256)|0)?[39]\\d{8}$/,\n};\n","/*  Source: Google LibPhoneNumber Metadata: https://github.com/google/libphonenumber/blob/master/javascript/i18n/phonenumbers/metadata.js  */\n\nexport const DIAL_CODE_MAPPER: { [key: number]: string[] } = {\n  1: [\n    'US',\n    'AG',\n    'AI',\n    'AS',\n    'BB',\n    'BM',\n    'BS',\n    'CA',\n    'DM',\n    'DO',\n    'GD',\n    'GU',\n    'JM',\n    'KN',\n    'KY',\n    'LC',\n    'MP',\n    'MS',\n    'PR',\n    'SX',\n    'TC',\n    'TT',\n    'VC',\n    'VG',\n    'VI',\n  ],\n  7: ['RU', 'KZ'],\n  20: ['EG'],\n  27: ['ZA'],\n  30: ['GR'],\n  31: ['NL'],\n  32: ['BE'],\n  33: ['FR'],\n  34: ['ES'],\n  36: ['HU'],\n  39: ['IT', 'VA'],\n  40: ['RO'],\n  41: ['CH'],\n  43: ['AT'],\n  44: ['GB', 'GG', 'IM', 'JE'],\n  45: ['DK'],\n  46: ['SE'],\n  47: ['NO', 'SJ'],\n  48: ['PL'],\n  49: ['DE'],\n  51: ['PE'],\n  52: ['MX'],\n  53: ['CU'],\n  54: ['AR'],\n  55: ['BR'],\n  56: ['CL'],\n  57: ['CO'],\n  58: ['VE'],\n  60: ['MY'],\n  61: ['AU', 'CC', 'CX'],\n  62: ['ID'],\n  63: ['PH'],\n  64: ['NZ'],\n  65: ['SG'],\n  66: ['TH'],\n  81: ['JP'],\n  82: ['KR'],\n  84: ['VN'],\n  86: ['CN'],\n  90: ['TR'],\n  91: ['IN'],\n  92: ['PK'],\n  93: ['AF'],\n  94: ['LK'],\n  95: ['MM'],\n  98: ['IR'],\n  211: ['SS'],\n  212: ['MA', 'EH'],\n  213: ['DZ'],\n  216: ['TN'],\n  218: ['LY'],\n  220: ['GM'],\n  221: ['SN'],\n  222: ['MR'],\n  223: ['ML'],\n  224: ['GN'],\n  225: ['CI'],\n  226: ['BF'],\n  227: ['NE'],\n  228: ['TG'],\n  229: ['BJ'],\n  230: ['MU'],\n  231: ['LR'],\n  232: ['SL'],\n  233: ['GH'],\n  234: ['NG'],\n  235: ['TD'],\n  236: ['CF'],\n  237: ['CM'],\n  238: ['CV'],\n  239: ['ST'],\n  240: ['GQ'],\n  241: ['GA'],\n  242: ['CG'],\n  243: ['CD'],\n  244: ['AO'],\n  245: ['GW'],\n  246: ['IO'],\n  247: ['AC'],\n  248: ['SC'],\n  249: ['SD'],\n  250: ['RW'],\n  251: ['ET'],\n  252: ['SO'],\n  253: ['DJ'],\n  254: ['KE'],\n  255: ['TZ'],\n  256: ['UG'],\n  257: ['BI'],\n  258: ['MZ'],\n  260: ['ZM'],\n  261: ['MG'],\n  262: ['RE', 'YT'],\n  263: ['ZW'],\n  264: ['NA'],\n  265: ['MW'],\n  266: ['LS'],\n  267: ['BW'],\n  268: ['SZ'],\n  269: ['KM'],\n  290: ['SH', 'TA'],\n  291: ['ER'],\n  297: ['AW'],\n  298: ['FO'],\n  299: ['GL'],\n  350: ['GI'],\n  351: ['PT'],\n  352: ['LU'],\n  353: ['IE'],\n  354: ['IS'],\n  355: ['AL'],\n  356: ['MT'],\n  357: ['CY'],\n  358: ['FI', 'AX'],\n  359: ['BG'],\n  370: ['LT'],\n  371: ['LV'],\n  372: ['EE'],\n  373: ['MD'],\n  374: ['AM'],\n  375: ['BY'],\n  376: ['AD'],\n  377: ['MC'],\n  378: ['SM'],\n  380: ['UA'],\n  381: ['RS'],\n  382: ['ME'],\n  383: ['XK'],\n  385: ['HR'],\n  386: ['SI'],\n  387: ['BA'],\n  389: ['MK'],\n  420: ['CZ'],\n  421: ['SK'],\n  423: ['LI'],\n  500: ['FK'],\n  501: ['BZ'],\n  502: ['GT'],\n  503: ['SV'],\n  504: ['HN'],\n  505: ['NI'],\n  506: ['CR'],\n  507: ['PA'],\n  508: ['PM'],\n  509: ['HT'],\n  590: ['GP', 'BL', 'MF'],\n  591: ['BO'],\n  592: ['GY'],\n  593: ['EC'],\n  594: ['GF'],\n  595: ['PY'],\n  596: ['MQ'],\n  597: ['SR'],\n  598: ['UY'],\n  599: ['CW', 'BQ'],\n  670: ['TL'],\n  672: ['NF'],\n  673: ['BN'],\n  674: ['NR'],\n  675: ['PG'],\n  676: ['TO'],\n  677: ['SB'],\n  678: ['VU'],\n  679: ['FJ'],\n  680: ['PW'],\n  681: ['WF'],\n  682: ['CK'],\n  683: ['NU'],\n  685: ['WS'],\n  686: ['KI'],\n  687: ['NC'],\n  688: ['TV'],\n  689: ['PF'],\n  690: ['TK'],\n  691: ['FM'],\n  692: ['MH'],\n  800: ['001'],\n  808: ['001'],\n  850: ['KP'],\n  852: ['HK'],\n  853: ['MO'],\n  855: ['KH'],\n  856: ['LA'],\n  870: ['001'],\n  878: ['001'],\n  880: ['BD'],\n  881: ['001'],\n  882: ['001'],\n  883: ['001'],\n  886: ['TW'],\n  888: ['001'],\n  960: ['MV'],\n  961: ['LB'],\n  962: ['JO'],\n  963: ['SY'],\n  964: ['IQ'],\n  965: ['KW'],\n  966: ['SA'],\n  967: ['YE'],\n  968: ['OM'],\n  970: ['PS'],\n  971: ['AE'],\n  972: ['IL'],\n  973: ['BH'],\n  974: ['QA'],\n  975: ['BT'],\n  976: ['MN'],\n  977: ['NP'],\n  979: ['001'],\n  992: ['TJ'],\n  993: ['TM'],\n  994: ['AZ'],\n  995: ['GE'],\n  996: ['KG'],\n  998: ['UZ'],\n};\n","import { DIAL_CODE_MAPPER } from './data/dialCodeMapper';\nimport { PHONE_REGEX_MAPPER } from './data/phoneRegexMapper';\n\n/**\n * Determines the country code based on the provided phone number.\n * This function employs a multi-step approach to identify the country code:\n * - If the phone number starts with '+', it extracts the numeric characters\n *   and matches the leading digits with known dial codes mapped to countries.\n * - For matched dial codes, it further filters based on country-specific regex patterns\n *   to validate the phone number format for those countries.\n * - If the phone number doesn't start with '+', it directly matches the number\n *   against regular expressions associated with various countries to identify the code.\n *\n * @param phoneNumber The input phone number (string or number).\n * @returns The detected country code or an empty string if not found.\n */\nexport const detectCountryCodeFromDialCode = (\n  phoneNumber: string | number,\n): string => {\n  // If the phone number starts with '+', extract numeric characters\n  if (phoneNumber.toString().charAt(0) === '+') {\n    const cleanedPhoneNumberWithoutPlusPrefix = phoneNumber\n      .toString()\n      .replace(/\\D/g, '');\n\n    const matchingCountries: string[] = [];\n\n    // Iterate through dial codes and check for matches with cleaned phone number\n    for (const code in DIAL_CODE_MAPPER) {\n      if (cleanedPhoneNumberWithoutPlusPrefix.startsWith(code)) {\n        matchingCountries.push(...DIAL_CODE_MAPPER[code]);\n      }\n    }\n\n    // Filter matching countries based on phone number validation regex\n    const matchedCountryCode = matchingCountries.find((countryCode: string) => {\n      const regex = PHONE_REGEX_MAPPER[countryCode];\n      if (regex && regex.test(phoneNumber.toString())) return countryCode;\n      return undefined;\n    });\n\n    // Return the first matched country code, if any\n    return matchedCountryCode || '';\n  } else {\n    // If phone number doesn't start with '+', directly match against country regexes\n    for (const countryCode in PHONE_REGEX_MAPPER) {\n      const regex = PHONE_REGEX_MAPPER[countryCode];\n      if (regex.test(phoneNumber.toString())) {\n        return countryCode;\n      }\n    }\n  }\n\n  // Return empty string if no country code is detected\n  return '';\n};\n\nexport const cleanPhoneNumber = (phoneNumber: string) => {\n  // Regular expression to match all characters except numbers and + sign at the start\n  const regex = /[^0-9+]|(?!A)\\+/g;\n  // Replace matched characters with an empty string\n  const cleanedPhoneNumber = phoneNumber.replace(regex, '');\n  return phoneNumber[0] === '+' ? `+${cleanedPhoneNumber}` : cleanedPhoneNumber;\n};\n","import { PHONE_REGEX_MAPPER } from './data/phoneRegexMapper';\nimport { withErrorBoundary } from '../../common/errorBoundary';\nimport { detectCountryCodeFromDialCode, cleanPhoneNumber } from './utils';\n\n// Validates whether a given phone number is valid based on the provided country code or auto-detects the country code and checks if the number matches the defined regex pattern for that country.\nconst isValidPhoneNumber = (\n  phoneNumber: string | number,\n  countryCode?: keyof typeof PHONE_REGEX_MAPPER,\n): boolean => {\n  // Clean the provided phoneNumber by removing non-numeric characters\n  const cleanedPhoneNumber = cleanPhoneNumber(phoneNumber.toString());\n\n  // Detect or validate the country code\n  countryCode =\n    countryCode && countryCode in PHONE_REGEX_MAPPER\n      ? countryCode\n      : detectCountryCodeFromDialCode(cleanedPhoneNumber);\n\n  // Return false if phoneNumber is empty\n  if (!phoneNumber) return false;\n\n  // Check if the countryCode exists in the PHONE_REGEX_MAPPER\n  if (countryCode in PHONE_REGEX_MAPPER) {\n    // Fetch the regex pattern for the countryCode\n    const regex = PHONE_REGEX_MAPPER[countryCode];\n    // Test if the cleanedPhoneNumber matches the regex pattern\n    return regex.test(cleanedPhoneNumber as string);\n  }\n\n  // Return false if the countryCode is not supported\n  return false;\n};\n\nexport default withErrorBoundary<typeof isValidPhoneNumber>(isValidPhoneNumber);\n","export const PHONE_FORMATTER_MAPPER: { [key: string]: string } = {\n  IN: 'xxxx xxxxxx',\n  MY: 'xx xxxxx xx',\n  AE: 'xx xxx xxxx',\n  AL: 'xxx xx xxxx',\n  AM: 'xx xx xx xx',\n  AR: 'xxxx-xxxx',\n  AU: 'xxx xxx xxx',\n  AW: 'xxx-xxxx',\n  BB: 'xxx-xxxx',\n  BD: 'xxxx-xxxxxx',\n  BM: 'xxx-xxxx',\n  BN: 'xxxx-xxxx',\n  BO: 'xxxx-xxxx',\n  BS: 'xxx-xxxx',\n  BW: 'xx xxxx xxxx',\n  BZ: 'xxx-xxxx',\n  CA: 'xxx-xxx-xxxx',\n  CH: 'xxx xxx xxx',\n  CN: 'xxxx-xxxxxxx',\n  CO: 'xxxx-xxxxxxx',\n  CR: 'xxxx-xxxx',\n  CU: 'xxxx-xxxx',\n  CZ: 'xxx xxx xxx',\n  DK: 'xx xx xx xx',\n  DO: 'xxx-xxxxxxx',\n  DZ: 'xxxx-xxxx-xxx',\n  EG: 'xx xxx xxxx',\n  ET: 'xx xxx xxxx',\n  EU: 'xxx xx xx xx',\n  FJ: 'xxxx xxxx',\n  GB: 'xxxx xxx xxx',\n  GH: 'xxx xxx xxxx',\n  GI: 'xxxx xxxx',\n  GM: 'xxxx-xxxx',\n  GT: 'xxxx-xxxx',\n  GY: 'xxx-xxxx',\n  HK: 'xxxx xxxx',\n  HN: 'xxxx-xxxx',\n  HR: 'xxx xxx xxxx',\n  HT: 'xxx-xxxx',\n  HU: 'xxx xxx xxxx',\n  ID: 'xxxx-xxxx-xxxx',\n  IL: 'xxxx-xxx-xxx',\n  JM: 'xxx-xxxx',\n  KE: 'xxx xxxxxx',\n  KG: 'xxx-xx-xx-xx',\n  KH: 'xxx-xxx-xxx',\n  KY: 'xxx-xxxx',\n  KZ: 'xxx-xxx-xx-xx',\n  LA: 'xxx xx xxxx',\n  LK: 'xx xxx xxxx',\n  LR: 'xxx-xxx-xxxx',\n  LS: 'xxx xx xxxx',\n  LT: 'xxx xxxxx',\n  LU: 'xxx xx xxx',\n  LV: 'xxxx xxxx',\n  MA: 'xxxx-xxxxxx',\n  MD: 'xx xxxxxx',\n  ME: 'xx xxxxxx',\n  MG: 'xx xx xx xx xx',\n  MK: 'xx xx xx xx',\n  MM: 'xx xxxxxx',\n  MN: 'xxx-xx-xxxx',\n  MO: 'xxxx xxxx',\n  MU: 'xx xxxx xxxx',\n  MV: 'xxxxxx',\n  MW: 'xx xxxx xxxx',\n  MX: 'xxx-xxx-xxxx',\n  MZ: 'xx xxxxxxx',\n  NA: 'xx xxxx xxxx',\n  NG: 'xxx xxx xxxx',\n  NI: 'xxxx-xxxx',\n  NL: 'xxx-xxxxxxx',\n  NO: 'xxxx xxxx',\n  NP: 'xxxx-xxxxxxx',\n  NZ: 'xxx-xxxxxxx',\n  OM: 'xxxx-xxxx',\n  PA: 'xxx-xxxx',\n  PE: 'xxx-xxx-xxx',\n  PG: 'xxx-xxxxxx',\n  PH: 'xxx-xxxx',\n  PK: 'xxx-xxxxxxx',\n  PL: 'xxx xxx xxx',\n  PR: 'xxx-xxx-xxxx',\n  PS: 'xxxx-xxxxxxx',\n  PT: 'xxx xxx xxx',\n  PY: 'xxx-xxxxxx',\n  QA: 'xxxx xxxx',\n  RO: 'xxx xxx xxxx',\n  RS: 'xxx xxxxx',\n  RU: 'xxx xxx-xx-xx',\n  RW: 'xxx xxxxxx',\n  SA: 'xxx-xxxxxxx',\n  SC: 'xx xxxxx',\n  SE: 'xxx-xxx xx xx',\n  SG: 'xxxx xxxx',\n  SI: 'xx xxxxxx',\n  SK: 'xxx xxx xxx',\n  SL: 'xxx-xxxxxx',\n  SM: 'xxxxx xxxxx',\n  SN: 'xx xxx xx xx',\n  SO: 'xxx xxxxxxx',\n  SR: 'xxx-xxxx',\n  SS: 'xxx xxxx xxx',\n  SV: 'xxxx-xxxx',\n  SZ: 'xxx xx xxxx',\n  TG: 'xx xx xx xx',\n  TH: 'xxx-xxxxxxx',\n  TJ: 'xxx xx xx xx',\n  TL: 'xxx-xxxxxxx',\n  TN: 'xx xxxxxx',\n  TR: 'xxx xxx xx xx',\n  TT: 'xxx-xxxx',\n  TW: 'xxxx-xxxxxx',\n  TZ: 'xxx xxx xxxx',\n  UA: 'xx xxx xx xx',\n  UG: 'xxx xxxxxxx',\n  US: 'xxx-xxx-xxxx',\n  UY: 'xxx-xxxxx',\n  UZ: 'xxx-xxx-xx-xx',\n  VC: 'xxx-xxxx',\n  VE: 'xxxx-xxx-xxxx',\n  VN: 'xxxx-xxxxxxx',\n  YE: 'xxxx-xxxx',\n  ZA: 'xxx-xxx-xxxx',\n  ZM: 'xxx-xxxxxxx',\n  ZW: 'xx xxx xxxx',\n  KW: 'xxx xx xxxx',\n  BH: 'xxxx xxxx',\n};\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { PHONE_FORMATTER_MAPPER } from './data/phoneFormatterMapper';\nimport { detectCountryCodeFromDialCode, cleanPhoneNumber } from './utils';\n\n// Formats a provided phone number according to the predefined format for a specific country code, or auto-detects the country code and formats the number accordingly.\nconst formatPhoneNumber = (\n  phoneNumber: string | number,\n  countryCode?: keyof typeof PHONE_FORMATTER_MAPPER,\n): string => {\n  // Throw errors if phoneNumber is invalid\n  if (!phoneNumber) throw new Error('Parameter `phoneNumber` is invalid!');\n\n  // Convert phoneNumber to string and clean it by removing non-numeric characters\n  phoneNumber = phoneNumber.toString();\n  phoneNumber = cleanPhoneNumber(phoneNumber);\n\n  // Detect or validate the country code\n  countryCode =\n    countryCode && countryCode in PHONE_FORMATTER_MAPPER\n      ? countryCode\n      : detectCountryCodeFromDialCode(phoneNumber);\n\n  // Fetch the pattern for the countryCode from the PHONE_FORMATTER_MAPPER\n  const pattern = PHONE_FORMATTER_MAPPER[countryCode];\n\n  if (!pattern) return phoneNumber;\n\n  // Count the number of 'x' characters in the format pattern\n  let charCountInFormatterPattern = 0;\n  for (let i = 0; i < pattern.length; i++) {\n    if (pattern[i] === 'x') {\n      charCountInFormatterPattern++;\n    }\n  }\n\n  // Calculate the difference between phoneNumber length and 'x' characters count in pattern\n  const diff = phoneNumber.length - charCountInFormatterPattern;\n  // Extract the phoneNumber without the prefix\n  const phoneNumberWithoutPrefix = phoneNumber.slice(diff);\n  const formattedNumber: string[] = [];\n  let numberIndex = 0;\n\n  // Loop through the pattern to format the phoneNumber\n  for (let i = 0; i < pattern.length; i++) {\n    const patternChar = pattern[i];\n    if (patternChar === 'x') {\n      // Insert phoneNumber digits at 'x' positions\n      if (numberIndex < phoneNumberWithoutPrefix.length) {\n        formattedNumber.push(phoneNumberWithoutPrefix[numberIndex]);\n        numberIndex++;\n      }\n    } else {\n      // Insert non-digit characters from the pattern\n      formattedNumber.push(patternChar);\n    }\n  }\n\n  // Join the formattedNumber array to create the formattedPhoneNumber without prefix\n  const formattedPhoneNumberWithoutPrefix = formattedNumber.join('');\n  // Combine the prefix and formattedPhoneNumberWithoutPrefix\n  const formattedPhoneNumberWithPrefix =\n    phoneNumber.slice(0, diff) + ' ' + formattedPhoneNumberWithoutPrefix;\n\n  // Return the formattedPhoneNumber with prefix after trimming whitespace\n  return formattedPhoneNumberWithPrefix.trim();\n};\n\nexport default withErrorBoundary<typeof formatPhoneNumber>(formatPhoneNumber);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { PHONE_FORMATTER_MAPPER } from './data/phoneFormatterMapper';\nimport formatPhoneNumber from './formatPhoneNumber';\nimport { detectCountryCodeFromDialCode, cleanPhoneNumber } from './utils';\n\ninterface PhoneInfo {\n  countryCode: string;\n  dialCode: string;\n  formattedPhoneNumber: string;\n  formatTemplate: string;\n}\n\n// Parses a given phone number, identifies its country code (if not provided), and returns an object with details including the country code, formatted phone number, dial code, and format template.\nconst parsePhoneNumber = (phoneNumber: string, country?: string): PhoneInfo => {\n  // Throw errors if phoneNumber is invalid\n  if (!phoneNumber) throw new Error('Parameter `phoneNumber` is invalid!');\n\n  // Clean the phoneNumber by removing non-numeric characters\n  phoneNumber = phoneNumber.toString();\n  phoneNumber = cleanPhoneNumber(phoneNumber);\n\n  // Detect or validate the country code\n  const countryCode =\n    country && country in PHONE_FORMATTER_MAPPER\n      ? country\n      : detectCountryCodeFromDialCode(phoneNumber);\n\n  // Format the phone number using the detected/validated country code\n  const formattedPhoneNumber = formatPhoneNumber(phoneNumber, countryCode);\n\n  // Fetch the pattern associated with the countryCode from the PHONE_FORMATTER_MAPPER\n  const pattern = PHONE_FORMATTER_MAPPER[countryCode];\n\n  if (!pattern)\n    return {\n      countryCode: countryCode || '',\n      dialCode: '',\n      formattedPhoneNumber: phoneNumber,\n      formatTemplate: '',\n    };\n\n  // Count the number of 'x' characters in the format pattern\n  let charCountInFormatterPattern = 0;\n  for (let i = 0; i < pattern.length; i++) {\n    if (pattern[i] === 'x') {\n      charCountInFormatterPattern++;\n    }\n  }\n\n  // Calculate the difference between phoneNumber length and 'x' characters count in pattern\n  const diff = phoneNumber.length - charCountInFormatterPattern;\n\n  // Extract the dialCode from the phoneNumber\n  const dialCode = phoneNumber.slice(0, diff);\n\n  // Obtain the format template associated with the countryCode\n  const formatTemplate = PHONE_FORMATTER_MAPPER[countryCode];\n\n  // Return the parsed phone number information\n  return {\n    countryCode,\n    formattedPhoneNumber,\n    dialCode,\n    formatTemplate,\n  };\n};\n\nexport default withErrorBoundary<typeof parsePhoneNumber>(parsePhoneNumber);\n","export const stringToDate = (dateString: string): Date => {\n  const supportedDateFormats = [\n    // Date formats\n    {\n      regex: /^(\\d{4})\\/(\\d{2})\\/(\\d{2})$/,\n      yearIndex: 1,\n      monthIndex: 2,\n      dayIndex: 3,\n    }, // YYYY/MM/DD\n    {\n      regex: /^(\\d{2})\\/(\\d{2})\\/(\\d{4})$/,\n      yearIndex: 3,\n      monthIndex: 2,\n      dayIndex: 1,\n    }, // DD/MM/YYYY\n    {\n      regex: /^(\\d{4})\\.(\\d{2})\\.(\\d{2})$/,\n      yearIndex: 1,\n      monthIndex: 2,\n      dayIndex: 3,\n    }, // YYYY.MM.DD\n    {\n      regex: /^(\\d{4})\\.(\\d{2})\\.(\\d{2})$/,\n      yearIndex: 1,\n      monthIndex: 2,\n      dayIndex: 3,\n    }, // DD-MM-YYYY\n    {\n      regex: /^(\\d{4})\\.(\\d{2})\\.(\\d{2})$/,\n      yearIndex: 1,\n      monthIndex: 2,\n      dayIndex: 3,\n    }, // MM/DD/YYYY\n    {\n      regex: /^(\\d{4})\\.(\\d{2})\\.(\\d{2})$/,\n      yearIndex: 1,\n      monthIndex: 2,\n      dayIndex: 3,\n    }, // YYYY-MM-DD\n    {\n      regex: /^(\\d{4})\\.(\\d{2})\\.(\\d{2})$/,\n      yearIndex: 1,\n      monthIndex: 2,\n      dayIndex: 3,\n    }, // YYYY. MM. DD.\n    {\n      regex: /^(\\d{4})\\.(\\d{2})\\.(\\d{2})$/,\n      yearIndex: 1,\n      monthIndex: 2,\n      dayIndex: 3,\n    }, // DD.MM.YYYY\n\n    // Timestamp formats\n    {\n      regex: /^(\\d{4})\\/(\\d{2})\\/(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2})$/,\n      yearIndex: 1,\n      monthIndex: 2,\n      dayIndex: 3,\n      hourIndex: 4,\n      minuteIndex: 5,\n      secondIndex: 6,\n    }, // YYYY/MM/DD HH:MM:SS\n    {\n      regex: /^(\\d{2})\\/(\\d{2})\\/(\\d{4}) (\\d{2}):(\\d{2}):(\\d{2})$/,\n      yearIndex: 3,\n      monthIndex: 2,\n      dayIndex: 1,\n      hourIndex: 4,\n      minuteIndex: 5,\n      secondIndex: 6,\n    }, // DD/MM/YYYY HH:MM:SS\n    {\n      regex: /^(\\d{4})-(\\d{2})-(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2})$/,\n      yearIndex: 1,\n      monthIndex: 2,\n      dayIndex: 3,\n      hourIndex: 4,\n      minuteIndex: 5,\n      secondIndex: 6,\n    }, // YYYY-MM-DD HH:MM:SS\n    {\n      regex: /^(\\d{2})-(\\d{2})-(\\d{4}) (\\d{2}):(\\d{2}):(\\d{2})$/,\n      yearIndex: 3,\n      monthIndex: 2,\n      dayIndex: 1,\n      hourIndex: 4,\n      minuteIndex: 5,\n      secondIndex: 6,\n    }, // DD-MM-YYYY HH:MM:SS\n    {\n      regex: /^(\\d{4})\\.(\\d{2})\\.(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2})$/,\n      yearIndex: 1,\n      monthIndex: 2,\n      dayIndex: 3,\n      hourIndex: 4,\n      minuteIndex: 5,\n      secondIndex: 6,\n    }, // YYYY.MM.DD HH:MM:SS\n    {\n      regex: /^(\\d{2})\\.(\\d{2})\\.(\\d{4}) (\\d{2}):(\\d{2}):(\\d{2})$/,\n      yearIndex: 3,\n      monthIndex: 2,\n      dayIndex: 1,\n      hourIndex: 4,\n      minuteIndex: 5,\n      secondIndex: 6,\n    }, // DD.MM.YYYY HH:MM:SS\n  ];\n\n  for (const format of supportedDateFormats) {\n    const match = dateString.match(format.regex);\n    if (match) {\n      const year = match[format.yearIndex];\n      const month = match[format.monthIndex];\n      const day = match[format.dayIndex];\n      const hour = format.hourIndex ? match[format.hourIndex] : '00';\n      const minute = format.minuteIndex ? match[format.minuteIndex] : '00';\n      const second = format.secondIndex ? match[format.secondIndex] : '00';\n\n      return new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}`);\n    }\n  }\n\n  throw new Error('Date format not recognized');\n};\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { DateInput } from './types';\nimport { stringToDate } from './utils';\n\n/**\n * Adds a specified amount of time to a date.\n *\n * @param date The original date.\n * @param value The amount to add.\n * @param unit The unit of time to add (e.g., 'days', 'months', 'years').\n * @returns A new Date object with the time added.\n */\nconst add = (\n  date: DateInput,\n  value: number,\n  unit: 'days' | 'months' | 'years',\n): Date => {\n  date =\n    typeof date === 'string' ? new Date(stringToDate(date)) : new Date(date);\n\n  switch (unit) {\n    case 'days':\n      date.setDate(date.getDate() + value);\n      break;\n    case 'months':\n      date.setMonth(date.getMonth() + value);\n      break;\n    case 'years':\n      date.setFullYear(date.getFullYear() + value);\n      break;\n  }\n  return date;\n};\n\nexport default withErrorBoundary<typeof add>(add);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport state from '../.internal/state';\nimport { getLocale } from '../.internal/utils';\nimport { DateInput, Locale } from './types';\nimport { stringToDate } from './utils';\n\n/**\n * Formats date and time based on the locale.\n * @param {DateInput} date - Date object or date string.\n * @param {Locale} locale - Locale string.\n * @param {DateTimeFormatOptions} options - Intl.DateTimeFormat options (optional).\n * @returns {string} Formatted date and time string.\n */\nconst formatDateTime = (\n  date: DateInput,\n  locale: Locale,\n  intlOptions: Intl.DateTimeFormatOptions = {},\n): string => {\n  /** retrieve locale from below areas in order of preference\n   * 1. locale (used in case if someone wants to override locale just for a specific area and not globally)\n   * 2. i18nState.locale (uses locale set globally)\n   * 3. navigator (in case locale is not passed or set, use it from browser's navigator)\n   * */\n  if (!locale) locale = state.getState().locale || getLocale();\n\n  date =\n    typeof date === 'string' ? new Date(stringToDate(date)) : new Date(date);\n\n  const dateObj: Date = date instanceof Date ? date : new Date(date);\n  let formatter;\n\n  try {\n    formatter = new Intl.DateTimeFormat(locale, intlOptions);\n  } catch (err) {\n    if (err instanceof Error) {\n      throw new Error(err.message);\n    } else {\n      throw new Error(`An unknown error occurred = ${err}`);\n    }\n  }\n\n  return formatter.format(dateObj);\n};\n\nexport default withErrorBoundary<typeof formatDateTime>(formatDateTime);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport state from '../.internal/state';\nimport { getLocale } from '../.internal/utils';\nimport formatDateTime from './formatDateTime';\nimport {\n  DateInput,\n  Locale,\n  DateTimeFormatOptions,\n  DateFormatOptions,\n} from './types';\n\n/**\n * Formats date based on the locale.\n * @param {DateInput} date - Date object or date string.\n * @param {Locale} locale - Locale string.\n * @param {DateFormatOptions} options - Intl.DateTimeFormat options for date formatting (optional).\n * @returns {string} Formatted date string.\n */\nconst formatDate = (\n  date: DateInput,\n  locale: Locale,\n  options: DateFormatOptions = {},\n): string => {\n  /** retrieve locale from below areas in order of preference\n   * 1. locale (used in case if someone wants to override locale just for a specific area and not globally)\n   * 2. i18nState.locale (uses locale set globally)\n   * 3. navigator (in case locale is not passed or set, use it from browser's navigator)\n   * */\n  if (!locale) locale = state.getState().locale || getLocale();\n\n  const fullOptions: DateTimeFormatOptions = {\n    ...options,\n    timeStyle: undefined,\n  };\n\n  let formattedDate;\n\n  try {\n    formattedDate = formatDateTime(date, locale, fullOptions);\n  } catch (err) {\n    if (err instanceof Error) {\n      throw new Error(err.message);\n    } else {\n      throw new Error(`An unknown error occurred = ${err}`);\n    }\n  }\n\n  return formattedDate;\n};\n\nexport default withErrorBoundary<typeof formatDate>(formatDate);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport state from '../.internal/state';\nimport { getLocale } from '../.internal/utils';\nimport formatDateTime from './formatDateTime';\nimport {\n  DateInput,\n  Locale,\n  DateTimeFormatOptions,\n  TimeFormatOptions,\n} from './types';\n\n/**\n * Formats time based on the locale.\n * @param {DateInput} date - Date object or date string.\n * @param {Locale} locale - Locale string.\n * @param {TimeFormatOptions} options - Intl.DateTimeFormat options for time formatting (optional).\n * @returns {string} Formatted time string.\n */\nconst formatTime = (\n  date: DateInput,\n  locale: Locale,\n  options: TimeFormatOptions = {},\n): string => {\n  /** retrieve locale from below areas in order of preference\n   * 1. locale (used in case if someone wants to override locale just for a specific area and not globally)\n   * 2. i18nState.locale (uses locale set globally)\n   * 3. navigator (in case locale is not passed or set, use it from browser's navigator)\n   * */\n  if (!locale) locale = state.getState().locale || getLocale();\n\n  const fullOptions: DateTimeFormatOptions = {\n    ...options,\n    dateStyle: undefined,\n  };\n\n  let formattedTime;\n\n  try {\n    formattedTime = formatDateTime(date, locale, fullOptions);\n  } catch (err) {\n    if (err instanceof Error) {\n      throw new Error(err.message);\n    } else {\n      throw new Error(`An unknown error occurred = ${err}`);\n    }\n  }\n\n  return formattedTime;\n};\n\nexport default withErrorBoundary<typeof formatTime>(formatTime);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport state from '../.internal/state';\nimport { getLocale } from '../.internal/utils';\n\n/**\n * Gets the first day of the week for a given locale.\n *\n * @param locale The locale to determine the first day of the week for.\n * @param intlOptions Optional Intl.DateTimeFormatOptions for customization.\n * @returns The first day of the week (0-6, where 0 is Sunday).\n */\nconst getFirstDayOfWeek = (\n  locale: string,\n  intlOptions: Intl.DateTimeFormatOptions = {},\n): string => {\n  /** retrieve locale from below areas in order of preference\n   * 1. locale (used in case if someone wants to override locale just for a specific area and not globally)\n   * 2. i18nState.locale (uses locale set globally)\n   * 3. navigator (in case locale is not passed or set, use it from browser's navigator)\n   * */\n  if (!locale) locale = state.getState().locale || getLocale();\n\n  let formatted;\n\n  if (!intlOptions.weekday) intlOptions.weekday = 'long';\n\n  try {\n    const formatter = new Intl.DateTimeFormat(locale, intlOptions);\n    /**\n     * This date was chosen because January 2, 2000, is a Sunday.\n     * In the Gregorian calendar, Sunday is considered the start of the week in some cultures (like in the United States), while in others, it's Monday (like in much of Europe).\n     * By using a date that is known to be a Sunday, the function can accurately determine what day of the week is considered the start in the specified locale.\n     */\n    const sundayDate = new Date(2000, 0, 2); // A known Sunday\n    formatted = formatter.format(sundayDate);\n  } catch (err) {\n    if (err instanceof Error) {\n      throw new Error(err.message);\n    } else {\n      throw new Error(`An unknown error occurred = ${err}`);\n    }\n  }\n\n  // Generate localized weekdays array starting from Sunday\n  const weekdays = Array.from({ length: 7 }, (_, i) =>\n    new Intl.DateTimeFormat(locale, intlOptions).format(\n      new Date(2000, 0, 2 + i),\n    ),\n  );\n\n  const firstDayIndex = weekdays.indexOf(formatted);\n  if (firstDayIndex === -1) {\n    throw new Error('Unable to determine the first day of the week');\n  }\n\n  return weekdays[(firstDayIndex + 1) % 7]; // Adjusting since our reference date is a Sunday\n};\n\nexport default withErrorBoundary<typeof getFirstDayOfWeek>(getFirstDayOfWeek);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { DateInput } from './types';\nimport { stringToDate } from './utils';\n\n/**\n * Determines the quarter of the year for a given date.\n *\n * @param date The date to determine the quarter for.\n * @returns The quarter of the year (1-4).\n */\nconst getQuarter = (date: DateInput): number => {\n  date =\n    typeof date === 'string' ? new Date(stringToDate(date)) : new Date(date);\n  return Math.ceil((date.getMonth() + 1) / 3);\n};\n\nexport default withErrorBoundary<typeof getQuarter>(getQuarter);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport state from '../.internal/state';\nimport { getLocale } from '../.internal/utils';\nimport { DateInput, Locale } from './types';\nimport { stringToDate } from './utils';\n\n/**\n * Provides a relative time string (e.g., '3 hours ago', 'in 2 days').\n * This function calculates the difference between the given date and the base date,\n * then formats it in a locale-sensitive manner. It allows customization of the output\n * through Intl.RelativeTimeFormat options.\n *\n * @param date - The date to compare.\n * @param baseDate - The date to compare against (default: current date).\n * @param locale - The locale to use for formatting.\n * @param options - Options for the Intl.RelativeTimeFormat (optional).\n * @returns The relative time as a string.\n */\nconst getRelativeTime = (\n  date: DateInput,\n  baseDate: DateInput = new Date(),\n  locale: Locale,\n  options?: Intl.RelativeTimeFormatOptions,\n): string => {\n  date =\n    typeof date === 'string' ? new Date(stringToDate(date)) : new Date(date);\n\n  baseDate =\n    typeof baseDate === 'string'\n      ? new Date(stringToDate(baseDate))\n      : new Date(baseDate);\n  /** retrieve locale from below areas in order of preference\n   * 1. locale (used in case if someone wants to override locale just for a specific area and not globally)\n   * 2. i18nState.locale (uses locale set globally)\n   * 3. navigator (in case locale is not passed or set, use it from browser's navigator)\n   * */\n  if (!locale) locale = state.getState().locale || getLocale();\n\n  const diffInSeconds = (date.getTime() - baseDate.getTime()) / 1000;\n\n  // Define time units in seconds\n  const minute = 60;\n  const hour = minute * 60;\n  const day = hour * 24;\n  const week = day * 7;\n  const month = day * 30;\n  const year = day * 365;\n\n  let value: number;\n  let unit: Intl.RelativeTimeFormatUnit;\n\n  if (Math.abs(diffInSeconds) < minute) {\n    value = diffInSeconds;\n    unit = 'second';\n  } else if (Math.abs(diffInSeconds) < hour) {\n    value = diffInSeconds / minute;\n    unit = 'minute';\n  } else if (Math.abs(diffInSeconds) < day) {\n    value = diffInSeconds / hour;\n    unit = 'hour';\n  } else if (Math.abs(diffInSeconds) < week) {\n    value = diffInSeconds / day;\n    unit = 'day';\n  } else if (Math.abs(diffInSeconds) < month) {\n    value = diffInSeconds / week;\n    unit = 'week';\n  } else if (Math.abs(diffInSeconds) < year) {\n    value = diffInSeconds / month;\n    unit = 'month';\n  } else {\n    value = diffInSeconds / year;\n    unit = 'year';\n  }\n\n  let relativeTime;\n\n  try {\n    const rtf = new Intl.RelativeTimeFormat(locale, options);\n    relativeTime = rtf.format(Math.round(value), unit);\n  } catch (err) {\n    if (err instanceof Error) {\n      throw new Error(err.message);\n    } else {\n      throw new Error(`An unknown error occurred = ${err}`);\n    }\n  }\n\n  return relativeTime;\n};\n\nexport default withErrorBoundary<typeof getRelativeTime>(getRelativeTime);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { DateInput } from './types';\nimport { stringToDate } from './utils';\n\n/**\n * Calculates the week number of the year for a given date.\n *\n * @param date The date to calculate the week number for.\n * @returns The week number of the year.\n */\nconst getWeek = (date: DateInput): number => {\n  date =\n    typeof date === 'string' ? new Date(stringToDate(date)) : new Date(date);\n  const firstDayOfYear = new Date(date.getFullYear(), 0, 1);\n  const pastDaysOfYear = (date.getTime() - firstDayOfYear.getTime()) / 86400000;\n  return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);\n};\n\nexport default withErrorBoundary<typeof getWeek>(getWeek);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport state from '../.internal/state';\nimport { getLocale } from '../.internal/utils';\nimport { Locale } from './types';\n\n/**\n * Returns an array of weekdays according to the specified locale.\n *\n * @param locale The locale to get weekdays for.\n * @param intlOptions Optional Intl.DateTimeFormatOptions for customization.\n * @returns An array of weekday names.\n */\nconst getWeekdays = (\n  locale: Locale,\n  intlOptions: Intl.DateTimeFormatOptions = {},\n): string[] => {\n  try {\n    /** retrieve locale from below areas in order of preference\n     * 1. locale (used in case if someone wants to override locale just for a specific area and not globally)\n     * 2. i18nState.locale (uses locale set globally)\n     * 3. navigator (in case locale is not passed or set, use it from browser's navigator)\n     * */\n    if (!locale) locale = state.getState().locale || getLocale();\n    if (!intlOptions.weekday) intlOptions.weekday = 'long';\n\n    const formatter = new Intl.DateTimeFormat(locale, intlOptions);\n\n    /** The date January 1, 1970, is a well-known reference point in computing known as the Unix epoch.\n     * It's the date at which time is measured for Unix systems, making it a consistent and reliable choice for date calculations.\n     * The choice of the date January 4, 1970, as the starting point is significant.\n     * January 4, 1970, was a Sunday.\n     * Since weeks typically start on Sunday or Monday in most locales, starting from a known Sunday allows the function to cycle through a complete week, capturing all weekdays in the order they appear for the given locale.\n     * */\n    return Array.from({ length: 7 }, (_, i) =>\n      formatter.format(new Date(1970, 0, 4 + i)),\n    );\n  } catch (err) {\n    if (err instanceof Error) {\n      throw new Error(err.message);\n    } else {\n      throw new Error(`An unknown error occurred = ${err}`);\n    }\n  }\n};\n\nexport default withErrorBoundary<typeof getWeekdays>(getWeekdays);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { DateInput } from './types';\nimport { stringToDate } from './utils';\n\n/**\n * Compares two dates to determine if the first is after the second.\n * @param {DateInput} date1 - First date object or date string.\n * @param {DateInput} date2 - Second date object or date string.\n * @returns {boolean} True if date1 is after date2.\n */\nconst isAfter = (date1: DateInput, date2: DateInput): boolean => {\n  date1 =\n    typeof date1 === 'string' ? new Date(stringToDate(date1)) : new Date(date1);\n  date2 =\n    typeof date2 === 'string' ? new Date(stringToDate(date2)) : new Date(date2);\n\n  const dateObj1: Date = date1 instanceof Date ? date1 : new Date(date1);\n  const dateObj2: Date = date2 instanceof Date ? date2 : new Date(date2);\n  return dateObj1 > dateObj2;\n};\n\nexport default withErrorBoundary<typeof isAfter>(isAfter);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { DateInput } from './types';\nimport { stringToDate } from './utils';\n\n/**\n * Compares two dates to determine if the first is before the second.\n * @param {DateInput} date1 - First date object or date string.\n * @param {DateInput} date2 - Second date object or date string.\n * @returns {boolean} True if date1 is before date2.\n */\nconst isBefore = (date1: DateInput, date2: DateInput): boolean => {\n  date1 =\n    typeof date1 === 'string' ? new Date(stringToDate(date1)) : new Date(date1);\n  date2 =\n    typeof date2 === 'string' ? new Date(stringToDate(date2)) : new Date(date2);\n\n  const dateObj1: Date = date1 instanceof Date ? date1 : new Date(date1);\n  const dateObj2: Date = date2 instanceof Date ? date2 : new Date(date2);\n  return dateObj1 < dateObj2;\n};\n\nexport default withErrorBoundary<typeof isBefore>(isBefore);\n","import { withErrorBoundary } from '../../common/errorBoundary';\n\n/**\n * Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @returns True if the year is a leap year, false otherwise.\n */\nconst isLeapYear = (year: number): boolean => {\n  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n};\n\nexport default withErrorBoundary<typeof isLeapYear>(isLeapYear);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { stringToDate } from './utils';\n\n/**\n * Checks if two dates fall on the same day.\n *\n * @param date1 The first date.\n * @param date2 The second date.\n * @returns True if both dates are on the same day, false otherwise.\n */\nconst isSameDay = (date1: Date, date2: Date): boolean => {\n  date1 =\n    typeof date1 === 'string' ? new Date(stringToDate(date1)) : new Date(date1);\n  date2 =\n    typeof date2 === 'string' ? new Date(stringToDate(date2)) : new Date(date2);\n\n  return (\n    date1.getDate() === date2.getDate() &&\n    date1.getMonth() === date2.getMonth() &&\n    date1.getFullYear() === date2.getFullYear()\n  );\n};\n\nexport default withErrorBoundary<typeof isSameDay>(isSameDay);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport { stringToDate } from './utils';\n\n/**\n * Checks if a given object is a valid Date object.\n *\n * @param date The object to check.\n * @returns True if the object is a valid Date, false otherwise.\n */\nconst isValidDate = (date: any): boolean => {\n  try {\n    date =\n      typeof date === 'string' ? new Date(stringToDate(date)) : new Date(date);\n  } catch (err) {\n    if (err instanceof Error) {\n      throw new Error(err.message);\n    } else {\n      throw new Error(`An unknown error occurred = ${err}`);\n    }\n  }\n\n  return date instanceof Date && !isNaN(date.getTime());\n};\n\nexport default withErrorBoundary<typeof isValidDate>(isValidDate);\n","export const LOCALE_DATE_FORMATS: { [key: string]: string } = {\n  'ar-AE': 'DD/MM/YYYY', // Arabic (U.A.E.)\n  'sq-AL': 'DD.MM.YYYY', // Albanian (Albania)\n  'hy-AM': 'DD.MM.YYYY', // Armenian (Armenia)\n  'es-AR': 'DD/MM/YYYY', // Spanish (Argentina)\n  'en-AU': 'DD/MM/YYYY', // English (Australia)\n  'nl-AW': 'DD-MM-YYYY', // Dutch (Aruba)\n  'en-BB': 'MM/DD/YYYY', // English (Barbados)\n  'bn-BD': 'DD/MM/YYYY', // Bengali (Bangladesh)\n  'en-BM': 'MM/DD/YYYY', // English (Bermuda)\n  'ms-BN': 'DD/MM/YYYY', // Malay (Brunei)\n  'es-BO': 'DD/MM/YYYY', // Spanish (Bolivia)\n  'en-BS': 'MM/DD/YYYY', // English (Bahamas)\n  'en-BW': 'DD/MM/YYYY', // English (Botswana)\n  'en-BZ': 'MM/DD/YYYY', // English (Belize)\n  'en-CA': 'DD/MM/YYYY', // English (Canada)\n  'de-CH': 'DD.MM.YYYY', // German (Switzerland)\n  'zh-CN': 'YYYY/MM/DD', // Chinese (China)\n  'es-CO': 'DD/MM/YYYY', // Spanish (Colombia)\n  'es-CR': 'DD/MM/YYYY', // Spanish (Costa Rica)\n  'es-CU': 'DD/MM/YYYY', // Spanish (Cuba)\n  'cs-CZ': 'DD.MM.YYYY', // Czech (Czech Republic)\n  'da-DK': 'DD-MM-YYYY', // Danish (Denmark)\n  'es-DO': 'DD/MM/YYYY', // Spanish (Dominican Republic)\n  'ar-DZ': 'DD/MM/YYYY', // Arabic (Algeria)\n  'ar-EG': 'DD/MM/YYYY', // Arabic (Egypt)\n  'am-ET': 'DD/MM/YYYY', // Amharic (Ethiopia)\n  'en-EU': 'DD/MM/YYYY', // English (European Union)\n  'en-FJ': 'DD/MM/YYYY', // English (Fiji)\n  'en-GB': 'DD/MM/YYYY', // English (United Kingdom)\n  'en-GH': 'DD/MM/YYYY', // English (Ghana)\n  'en-GI': 'DD/MM/YYYY', // English (Gibraltar)\n  'en-GM': 'DD/MM/YYYY', // English (Gambia)\n  'es-GT': 'DD/MM/YYYY', // Spanish (Guatemala)\n  'en-GY': 'DD/MM/YYYY', // English (Guyana)\n  'en-HK': 'DD/MM/YYYY', // English (Hong Kong)\n  'es-HN': 'DD/MM/YYYY', // Spanish (Honduras)\n  'hr-HR': 'DD.MM.YYYY', // Croatian (Croatia)\n  'ht-HT': 'MM/DD/YYYY', // Haitian (Haiti)\n  'hu-HU': 'YYYY. MM. DD.', // Hungarian (Hungary)\n  'id-ID': 'DD/MM/YYYY', // Indonesian (Indonesia)\n  'he-IL': 'DD/MM/YYYY', // Hebrew (Israel)\n  'en-IN': 'DD-MM-YYYY', // English (India)\n  'en-JM': 'MM/DD/YYYY', // English (Jamaica)\n  'en-KE': 'DD/MM/YYYY', // English (Kenya)\n  'ky-KG': 'DD.MM.YYYY', // Kyrgyz (Kyrgyzstan)\n  'km-KH': 'DD/MM/YYYY', // Khmer (Cambodia)\n  'en-KY': 'MM/DD/YYYY', // English (Cayman Islands)\n  'kk-KZ': 'DD.MM.YYYY', // Kazakh (Kazakhstan)\n  'lo-LA': 'DD/MM/YYYY', // Lao (Laos)\n  'si-LK': 'YYYY-MM-DD', // Sinhala (Sri Lanka)\n  'en-LR': 'MM/DD/YYYY', // English (Liberia)\n  'en-LS': 'DD/MM/YYYY', // English (Lesotho)\n  'ar-MA': 'DD/MM/YYYY', // Arabic (Morocco)\n  'ro-MD': 'DD.MM.YYYY', // Romanian (Moldova)\n  'mk-MK': 'DD.MM.YYYY', // Macedonian (North Macedonia)\n  'my-MM': 'DD/MM/YYYY', // Burmese (Myanmar)\n  'mn-MN': 'YYYY.MM.DD', // Mongolian (Mongolia)\n  'zh-MO': 'DD/MM/YYYY', // Chinese (Macao)\n  'en-MU': 'DD/MM/YYYY', // English (Mauritius)\n  'dv-MV': 'DD/MM/YYYY', // Divehi (Maldives)\n  'en-MW': 'DD/MM/YYYY', // English (Malawi)\n  'es-MX': 'DD/MM/YYYY', // Spanish (Mexico)\n  'ms-MY': 'DD/MM/YYYY', // Malay (Malaysia)\n  'en-NA': 'DD/MM/YYYY', // English (Namibia)\n  'en-NG': 'DD/MM/YYYY', // English (Nigeria)\n  'es-NI': 'DD/MM/YYYY', // Spanish (Nicaragua)\n  'no-NO': 'DD.MM.YYYY', // Norwegian (Norway)\n  'ne-NP': 'YYYY/MM/DD', // Nepali (Nepal)\n  'en-NZ': 'DD/MM/YYYY', // English (New Zealand)\n  'es-PE': 'DD/MM/YYYY', // Spanish (Peru)\n  'en-PG': 'DD/MM/YYYY', // English (Papua New Guinea)\n  'en-PH': 'MM/DD/YYYY', // English (Philippines)\n  'en-PK': 'DD/MM/YYYY', // English (Pakistan)\n  'ar-QA': 'DD/MM/YYYY', // Arabic (Qatar)\n  'ru-RU': 'DD.MM.YYYY', // Russian (Russia)\n  'ar-SA': 'DD/MM/YYYY', // Arabic (Saudi Arabia)\n  'en-SC': 'DD/MM/YYYY', // English (Seychelles)\n  'sv-SE': 'YYYY-MM-DD', // Swedish (Sweden)\n  'en-SG': 'DD/MM/YYYY', // English (Singapore)\n  'en-SL': 'DD/MM/YYYY', // English (Sierra Leone)\n  'so-SO': 'DD/MM/YYYY', // Somali (Somalia)\n  'en-SS': 'DD/MM/YYYY', // English (South Sudan)\n  'es-SV': 'DD/MM/YYYY', // Spanish (El Salvador)\n  'en-SZ': 'DD/MM/YYYY', // English (Eswatini)\n  'th-TH': 'DD/MM/YYYY', // Thai (Thailand)\n  'en-TT': 'MM/DD/YYYY', // English (Trinidad and Tobago)\n  'sw-TZ': 'DD/MM/YYYY', // Swahili (Tanzania)\n  'en-US': 'MM/DD/YYYY', // English (United States)\n  'es-UY': 'DD/MM/YYYY', // Spanish (Uruguay)\n  'uz-UZ': 'DD/MM/YYYY', // Uzbek (Uzbekistan)\n  'ar-YE': 'DD/MM/YYYY', // Arabic (Yemen)\n  'en-ZA': 'YYYY/MM/DD', // English (South Africa)\n  'ar-KW': 'DD/MM/YYYY', // Arabic (Kuwait)\n  'ar-BH': 'DD/MM/YYYY', // Arabic (Bahrain)\n  'ar-OM': 'DD/MM/YYYY', // Arabic (Oman)\n};\n","import { withErrorBoundary } from '../../common/errorBoundary';\n\n/**\n * Parses a date string based on a specific format.\n *\n * @param dateString The date string to parse.\n * @param format The format to use for parsing.\n * @returns The parsed Date object or null if parsing fails.\n */\nconst parseDateWithFormat = (\n  dateString: string,\n  format: string,\n): Date | null => {\n  // Determine the separator based on the format (supports '/', '.', or '-')\n  const separator = format.includes('/')\n    ? '/'\n    : format.includes('.')\n    ? '.'\n    : '-';\n  const formatParts = format.split(separator);\n  const dateParts = dateString.split(separator).map((num) => parseInt(num, 10));\n\n  let year: number = 0,\n    month: number = 0,\n    day: number = 0;\n  let yearSet: boolean = false,\n    monthSet: boolean = false,\n    daySet: boolean = false;\n\n  // Check for format and date string mismatch\n  if (dateParts.length !== formatParts.length) {\n    return null; // Mismatch between date string and format\n  }\n\n  formatParts.forEach((part, index) => {\n    // Check for non-numeric values in date string\n    if (isNaN(dateParts[index])) {\n      return null; // Invalid date part\n    }\n\n    // Assign year, month, and day based on the format\n    switch (part) {\n      case 'DD':\n        day = dateParts[index];\n        daySet = true;\n        break;\n      case 'MM':\n        month = dateParts[index] - 1; // Adjust for zero-indexed months in JavaScript Date\n        monthSet = true;\n        break;\n      case 'YYYY':\n        year = dateParts[index];\n        yearSet = true;\n        break;\n    }\n  });\n\n  // Validate and create the date only if all parts are set\n  if (yearSet && monthSet && daySet) {\n    const parsedDate = new Date(year, month, day);\n    // Validate date to catch invalid dates like February 30th\n    if (\n      parsedDate.getFullYear() === year &&\n      parsedDate.getMonth() === month &&\n      parsedDate.getDate() === day\n    ) {\n      return parsedDate;\n    }\n  }\n  return null; // Invalid date or incomplete date information\n};\n\nexport default withErrorBoundary<typeof parseDateWithFormat>(\n  parseDateWithFormat,\n);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport state from '../.internal/state';\nimport { getLocale } from '../.internal/utils';\nimport { LOCALE_DATE_FORMATS } from './data/localeDateFormats';\nimport parseDateWithFormat from './parseDateWithFormat';\nimport { Locale } from './types';\n\n/**\n * Attempts to parse a string into a date object based on locale.\n * Uses the localeDateFormats mapping for determining the date format.\n *\n * @param dateString - The date string to parse.\n * @param locale - The locale to use for parsing.\n * @returns The parsed Date object or null if parsing fails.\n */\nconst parseDate = (dateString: string, locale: Locale): Date | null => {\n  /** retrieve locale from below areas in order of preference\n   * 1. locale (used in case if someone wants to override locale just for a specific area and not globally)\n   * 2. i18nState.locale (uses locale set globally)\n   * 3. navigator (in case locale is not passed or set, use it from browser's navigator)\n   * */\n  if (!locale) locale = state.getState().locale || getLocale();\n\n  const format = LOCALE_DATE_FORMATS[locale];\n  if (!format) {\n    throw new Error(`No date format found for locale: ${locale}`);\n  }\n  return parseDateWithFormat(dateString, format);\n};\n\nexport default withErrorBoundary<typeof parseDate>(parseDate);\n","import { withErrorBoundary } from '../../common/errorBoundary';\nimport add from './add';\nimport { DateInput } from './types';\nimport { stringToDate } from './utils';\n\n/**\n * Subtracts a specified amount of time from a date.\n *\n * @param date The original date.\n * @param value The amount to subtract.\n * @param unit The unit of time to subtract (e.g., 'days', 'months', 'years').\n * @returns A new Date object with the time subtracted.\n */\nconst subtract = (\n  date: DateInput,\n  value: number,\n  unit: 'days' | 'months' | 'years',\n): Date => {\n  date =\n    typeof date === 'string' ? new Date(stringToDate(date)) : new Date(date);\n\n  return add(date, -value, unit); // Reuse the add function with negative value\n};\n\nexport default withErrorBoundary<typeof subtract>(subtract);\n"],"names":["I18nifyError","Error","constructor","message","super","this","name","timestamp","Date","withErrorBoundary","fn","rest","call","err","console","warn","I18nStateManager","state","locale","direction","country","getInstance","instance","resetInstance","undefined","getState","Object","assign","setState","newState","resetState","getState$1","setState$1","resetState$1","getLocale","navigator","window","Intl","languages","language","getIntlInstanceWithOptions","options","intlOptions","currency","style","NumberFormat","formatNumber$1","amount","Number","formattedAmount","format","CURRENCIES","AED","symbol","ALL","AMD","ARS","AUD","AWG","BBD","BDT","BMD","BND","BOB","BSD","BWP","BZD","CAD","CHF","CNY","COP","CRC","CUP","CZK","DKK","DOP","DZD","EGP","ETB","EUR","FJD","GBP","GHS","GIP","GMD","GTQ","GYD","HKD","HNL","HRK","HTG","HUF","IDR","ILS","INR","JMD","KES","KGS","KHR","KYD","KZT","LAK","LKR","LRD","LSL","MAD","MDL","MKD","MMK","MNT","MOP","MUR","MVR","MWK","MXN","MYR","NAD","NGN","NIO","NOK","NPR","NZD","PEN","PGK","PHP","PKR","QAR","RUB","SAR","SCR","SEK","SGD","SLL","SOS","SSP","SVC","SZL","THB","TTD","TZS","USD","UYU","UZS","YER","ZAR","KWD","BHD","OMR","getCurrencyList$1","getCurrencySymbol$1","currencyCode","_a","ALLOWED_FORMAT_PARTS_KEYS","formatNumberByParts$1","parts","formatToParts","formattedObj","forEach","p","type","integer","value","findIndex","item","isPrefixSymbol","rawParts","PHONE_REGEX_MAPPER","IN","MY","AE","AL","AM","AR","AU","AW","BB","BD","BM","BN","BO","BS","BW","BZ","CH","CN","CO","OM","CR","CU","CZ","DK","DO","DZ","EG","ET","EU","FJ","GB","GH","GI","GM","GT","GY","HK","HN","HR","HT","HU","ID","IL","JM","KE","KG","KH","KY","KZ","LA","LK","LR","LS","MA","MD","MK","MM","MN","MO","MU","MV","MW","MX","NA","NG","NI","NO","NP","NZ","PE","PG","PH","PK","QA","RU","SA","SC","SE","SG","SL","SO","SS","SV","SZ","TH","TT","TZ","US","CA","UY","UZ","YE","ZA","KW","BH","TL","VC","VE","VN","ZM","ZW","LT","LU","LV","ME","MG","MZ","NL","PA","PL","PR","PS","PT","PY","RO","RS","RW","SI","SK","SM","SN","SR","TG","TJ","TN","TR","TW","UA","UG","DIAL_CODE_MAPPER","detectCountryCodeFromDialCode","phoneNumber","toString","charAt","cleanedPhoneNumberWithoutPlusPrefix","replace","matchingCountries","code","startsWith","push","find","countryCode","regex","test","cleanPhoneNumber","cleanedPhoneNumber","isValidPhoneNumber$1","PHONE_FORMATTER_MAPPER","formatPhoneNumber$1","pattern","charCountInFormatterPattern","i","length","diff","phoneNumberWithoutPrefix","slice","formattedNumber","numberIndex","patternChar","formattedPhoneNumberWithoutPrefix","join","trim","parsePhoneNumber$1","formattedPhoneNumber","formatPhoneNumber","dialCode","formatTemplate","stringToDate","dateString","supportedDateFormats","yearIndex","monthIndex","dayIndex","hourIndex","minuteIndex","secondIndex","match","year","month","day","hour","minute","second","add$1","date","unit","setDate","getDate","setMonth","getMonth","setFullYear","getFullYear","formatDateTime$1","dateObj","formatter","DateTimeFormat","formatDate$1","fullOptions","timeStyle","formattedDate","formatDateTime","formatTime$1","dateStyle","formattedTime","getFirstDayOfWeek$1","formatted","weekday","sundayDate","weekdays","Array","from","_","firstDayIndex","indexOf","getQuarter$1","Math","ceil","getRelativeTime$1","baseDate","diffInSeconds","getTime","week","relativeTime","abs","RelativeTimeFormat","round","getWeek$1","firstDayOfYear","pastDaysOfYear","getDay","getWeekdays$1","isAfter$1","date1","date2","isBefore$1","isLeapYear$1","isSameDay$1","isValidDate$1","isNaN","LOCALE_DATE_FORMATS","parseDateWithFormat$1","separator","includes","formatParts","split","dateParts","map","num","parseInt","yearSet","monthSet","daySet","part","index","parsedDate","parseDate$1","parseDateWithFormat","subtract$1","add"],"mappings":"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AAC,MACL,GAAI,CAAC,MACL,GAAI,CAAC,MACL,GAAI,CAAC,MACL,GAAI,CAAC,MACL,IAAK,CAAC,MACN,IAAK,CAAC,KAAM,MACZ,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,KAAM,MACZ,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,KAAM,MACZ,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,KAAM,MACZ,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,KAAM,KAAM,MAClB,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,KAAM,MACZ,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,OACN,IAAK,CAAC,OACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,OACN,IAAK,CAAC,OACN,IAAK,CAAC,MACN,IAAK,CAAC,OACN,IAAK,CAAC,OACN,IAAK,CAAC,OACN,IAAK,CAAC,MACN,IAAK,CAAC,OACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,IAAK,CAAC,MACN,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"}